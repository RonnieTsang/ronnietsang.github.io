<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[RonnieTsang's Blog]]></title>
  <link href="http://RonnieTsang.github.io/atom.xml" rel="self"/>
  <link href="http://RonnieTsang.github.io/"/>
  <updated>2014-10-20T09:58:08+08:00</updated>
  <id>http://RonnieTsang.github.io/</id>
  <author>
    <name><![CDATA[RonnieTsang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算机基础(一): 操作系统篇 -- 线程同步]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-thread-synchronization/"/>
    <updated>2014-10-06T07:16:07+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-thread-synchronization</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机基础(一): 操作系统篇 -- 进程间通信]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-interprocess-communication/"/>
    <updated>2014-10-06T07:14:51+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-interprocess-communication</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机基础(一): 操作系统篇 -- 进程与线程的比较]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-process-and-thread/"/>
    <updated>2014-10-06T07:13:41+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-process-and-thread</id>
    <content type="html"><![CDATA[<h2>一、概述</h2>

<h3>（1）进程和线程的比较</h3>

<p><strong>我们通常看到的说法是这样的</strong>：</p>

<p>按照教科书上的定义，<strong>进程是资源管理的最小单位，线程是程序执行的最小单位</strong>。</p>

<p><strong>进程可以认为是程序执行时的一个实例</strong>。进程是系统进行资源分配的独立实体，且每个进程拥有独立的地址空间。一个进程无法直接访问另一个进程的变量和数据结构，如果希望让一个进程访问另一个进程的资源，需要使用进程间通信，比如：管道，文件， 套接字等。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</p>

<p><strong>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。</strong> 线程与进程的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存(一个进程无法直接访问另一进程的内存)。同时，每个线程还拥有自己的寄存器和栈，其它线程可以读写这些栈内存。</p>

<p><strong>线程是进程的一个特定执行路径。</strong>当一个线程修改了进程中的资源， 它的兄弟线程可以立即看到这种变化。线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>

<p><strong>总的来说，进程是资源分配的最小单位，线程则是程序执行的最小单位。</strong></p>

<!-- more -->


<p>更详细的分析，包括：</p>

<blockquote><ul>
<li>进程是系统进行资源分配的基本单位，有独立的内存地址空间； 线程是CPU调度的基本单位，没有单独地址空间，有独立的栈，局部变量，寄存器，程序计数器等</li>
<li>创建进程的开销大，包括创建虚拟地址空间等需要大量系统资源；创建线程开销小，基本上只有一个内核对象和一个堆栈</li>
<li>一个进程无法直接访问另一个进程的资源；同一进程内的多个线程共享进程的资源</li>
<li>进程切换开销大；线程切换开销小</li>
<li>进程间通信开销大；线程间通信开销小</li>
<li>线程属于进程，不能独立执行。每个进程至少要有一个线程，成为主线程</li>
</ul>
</blockquote>

<h3>（2）多进程和多线程的选择</h3>

<blockquote><ul>
<li>多进程的程序要比多线程的程序<strong>健壮</strong>，线程虽然有自己的堆栈和局部变量，但线程没有单独的地址空间，一个线程死掉就等于整个进程死掉。但在进程切换时，耗费资源较大，<strong>效率</strong>要差一些，因此：</li>
<li>当我们需要一种相对比较<strong>节俭</strong>的多任务操作方式的情况下，多线程提供了很不错的解决方案，因为同一个进程的多个线程彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的<strong>空间</strong>，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的<strong>时间</strong></li>
<li>多线程的另一个明显的优点是线程间方便的<strong>通信</strong>机制。对不同进程来说，由于它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这不仅费时且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，快捷又方便。（当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。）</li>
<li>对于一些要求同时进行并且又要<strong>共享</strong>某些变量的<strong>并发</strong>操作，只能用多线程，不能用多进程</li>
</ul>
</blockquote>

<p>正如当年采用多进程模型代替单进程模型一样，多线程程序使设计更简洁、功能更完备，程序的执行效率也更高。除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，有以下的优点：</p>

<blockquote><ul>
<li>提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。</li>
<li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</li>
</ul>
</blockquote>

<p>从函数调用上来说，进程创建使用<code>fork()</code>操作；线程创建使用<code>clone()</code>操作。 <a href="http://www.kohala.com/start/">Richard Stevens</a>大师这样说过：</p>

<blockquote><p> <strong>fork is expensive.</strong> Memory is copied from the parent to the child， all descriptors are duplicated in the child， and so on. Current implementations use a technique called <code>copy-on-write</code>， which avoids a copy of the parent&rsquo;s data space to the child until the child needs its own copy. But， regardless of this optimization， fork is expensive.</p>

<p><strong>IPC is required to pass information between the parent and child after the fork.</strong> Passing information from the parent to the child before the fork is easy， since the child starts with a copy of the parent&rsquo;s data space and with a copy of all the parent&rsquo;s descriptors. But， returning information from the child to the parent takes more work.</p>

<p><strong>Threads help with both problems.</strong> Threads are sometimes called <code>lightweight processes</code> since a thread is &ldquo;lighter weight&rdquo; than a process. That is， thread creation can be 10–100 times faster than process creation.</p>

<p>All threads within a process share the same global memory. This makes the sharing of information easy between the threads， but along with this <code>simplicity</code> comes the problem of <code>synchronization</code>.</p></blockquote>

<h3>（3）从操作系统角度看</h3>

<p>我们知道，操作系统有两个主要用途：</p>

<blockquote><ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。</li>
</ul>
</blockquote>

<p>操作系统通过以下几个不同层级的抽象概念实现这两个用途：</p>

<blockquote><ul>
<li><strong>文件：对I/O设备的抽象；</strong></li>
<li><strong>虚拟存储器：对I/O设备、主存储器的抽象</strong>；</li>
<li><strong>进程：对I/O设备、主存储器和处理器的抽象。</strong></li>
</ul>
</blockquote>

<p>这几个概念是<strong>相当基础而且重要</strong>的，进程是操作系统对运行中的程序的一种抽象。在一个系统中可以同时运行多个进程，而每个进程都好像在独占地使用硬件。我们称之为<code>并发运行</code>，实际上是说一个进程的指令和另一个进程的指令是交错执行的，操作系统实现这种交错执行的机制称为<code>上下文切换(context switching)</code>。</p>

<p>而在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。这在前文已经有过说明了。</p>

<p>虚拟存储器，则为每个进程提供了一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称之<code>为虚拟地址空间</code>。</p>

<p><code>（关于虚拟存储器，我会找时间专门整理一篇详尽的文章进行总结，希望不会等太久）</code></p>

<p>最后，文件只不过就是<code>字节序列</code>。每个I/O设备都可以看成是文件，系统中的所有输入输出都是通过使用称为Unix I/O的一小组系统函数调用读写文件来实现的。文件这个简单而精致的概念是非常强大的，因为它使得应用程序能够统一地看待系统中可能含有的各种I/O设备。</p>

<hr />

<h2>二、线程的实现方式</h2>

<p>在上一篇文章中，我们已经对进程的状态及其转换有所了解，这里我们会对线程做进一步的认识，关于<code>线程的实现方式</code>，或者说，<code>用户线程与内核线程的区别</code>。</p>

<p>线程的实现可以分为两类：<code>用户级线程</code> (User-Level Thread)和 <code>内核线线程</code> (Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。<strong>分类的标准主要是线程的调度者在核内还是在核外</strong>。<strong>前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。</strong>（在操作系统设计上，从进程演化出线程，最主要的目的就是<strong>更好的支持 <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> 以及减小（进程/线程）上下文切换开销</strong>。）</p>

<p><strong>用户线程</strong>指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</p>

<p><strong>内核线程</strong>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。</p>

<p>以下是用户级线程和内核级线程的区别：</p>

<blockquote><ul>
<li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li>
<li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li>
<li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li>
</ul>
</blockquote>

<p>在目前的商用系统中，通常都将两者结合起来使用，既提供<strong>核心线程</strong>以满足 SMP 系统的需要，也支持用<strong>线程库</strong>的方式在用户态实现另一套线程机制，此时一个核心线程同时成为多个用户态线程的调度者。正如很多技术一样，&#8221;混合&#8221;通常都能带来更高的效率，但同时也带来更大的实现难度，出于&#8221;简单&#8221;的设计思路，Linux从一开始就没有实现混合模型的计划，但它在实现上采用了另一种思路的&#8221;混合&#8221;。</p>

<p>在线程机制的具体实现上，可以在操作系统内核上实现线程，也可以在核外实现，后者显然要求核内至少实现了进程，而前者则一般要求在核内同时也支持进程。核心级线程模型显然要求前者的支持，而用户级线程模型则不一定基于后者实现。这种差异，正如前所述，是两种分类方式的标准不同带来的。</p>

<p>当核内既支持进程也支持线程时，就可以实现线程-进程的&#8221;多对多&#8221;模型，即一个进程的某个线程由核内调度，而同时它也可以作为用户级线程池的调度者，选择合适的用户级线程在其空间中运行。这就是前面提到的&#8221;混合&#8221;线程模型，既可满足多处理机系统的需要，也可以最大限度的减小调度开销。绝大多数商业操作系统（如Digital Unix、Solaris、Irix）都采用的这种能够完全实现 <a href="http://en.wikipedia.org/wiki/POSIX_Threads">POSIX1003.1c</a> 标准的线程模型。</p>

<p>在核外实现的线程又可以分为&#8221;一对一&#8221;、&#8221;多对一&#8221;两种模型，前者用一个核心进程（也许是轻量进程）对应一个线程，将线程调度等同于进程调度，交给核心完成，而后者则完全在核外实现多线程，调度也在用户态完成。后者就是前面提到的单纯的用户级线程模型的实现方式，显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，但同时因为核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大，因此，在现实中，纯用户级线程的实现，除算法研究目的以外，几乎已经消失了。</p>

<p>Linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制 <a href="http://en.wikipedia.org/wiki/LinuxThreads">LinuxThreads</a> 所采用的就是线程-进程&#8221;一对一&#8221;模型，调度交给核心，而在用户级实现一个包括信号处理在内的线程管理机制。</p>

<p>在 Linux2.6 以前，pthread 线程库对应的实现就是这个名叫 LinuxThreads 的 lib，由 <a href="http://en.wikipedia.org/wiki/Xavier_Leroy">Xavier Leroy</a> 负责开发完成，并已绑定在 GLIBC 中发行。它所实现的就是基于核心轻量级进程的&#8221;一对一&#8221;线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。</p>

<h3><strong>LinuxThread的线程机制</strong></h3>

<p>&ldquo;一对一&#8221;模型的好处之一是线程的调度由核心完成了，而其他诸如线程取消、线程间的同步等工作，都是在核外线程库中完成的。在LinuxThreads中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建（__clone()）并启动管理线程。</p>

<p>在一个进程空间内，管理线程与其他线程之间通过一对&#8221;管理管道（manager_pipe<a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">2</a>）&#8221;来通讯，该管道在创建管理线程之前创建，在成功启动了管理线程之后，管理管道的读端和写端分别赋给两个全局变量<strong>pthread_manager_reader和</strong>pthread_manager_request，之后，每个用户线程都通过<strong>pthread_manager_request向管理线程发请求，但管理线程本身并没有直接使用</strong>pthread_manager_reader，管道的读端（manager_pipe[0]）是作为__clone()的参数之一传给管理线程的，管理线程的工作主要就是监听管道读端，并对从中取出的请求作出反应。</p>

<p>使用 pthread 以后，在用户看来，每一个 task_struct 就对应一个线程，而一组线程以及它们所共同引用的一组资源就是一个进程。</p>

<p>但是，一组线程并不仅仅是引用同一组资源就够了，它们还必须被视为一个整体。对此，POSIX 标准提出了如下要求：</p>

<ol>
<li>查看进程列表的时候，相关的一组 task_struct 应当被展现为列表中的一个节点</li>
<li>发送给这个&#8221;进程&#8221;的信号(对应 kill 系统调用)，将被对应的这一组 task_struct 所共享，并且被其中的任意一个&#8221;线程&#8221;处理</li>
<li>发送给某个&#8221;线程&#8221;的信号(对应 pthread_kill)，将只被对应的一个 task_struct 接收，并且由它自己来处理</li>
<li>当&#8221;进程&#8221;被停止或继续时(对应 SIGSTOP/SIGCONT 信号)，对应的这一组 task_struct 状态将改变</li>
<li>当&#8221;进程&#8221;收到一个致命信号(比如由于段错误收到 SIGSEGV 信号)，对应的这一组 task_struct 将全部退出</li>
<li>等等(以上可能不够全)</li>
</ol>


<p>LinuxThreads 利用前面提到的轻量级进程来实现线程，但是对于 POSIX 提出的那些要求，LinuxThreads 除了第5点以外，都没有实现(实际上是无能为力，至于原因，后文谈到 LinuxThreads 的不足时会解释)：</p>

<blockquote><ul>
<li>如果运行了A程序，A程序创建了10个线程，那么在shell下执行ps命令时将看到11个A进程，而不是1个(注意，也不是10个，下面会解释)</li>
<li>不管是kill还是pthread_kill，信号只能被一个对应的线程所接收</li>
<li>SIGSTOP/SIGCONT信号只对一个线程起作用</li>
</ul>
</blockquote>

<p>还好 LinuxThreads 实现了第5点，我认为这一点是最重要的。如果某个线程&#8221;挂&#8221;了，整个进程还在若无其事地运行着，可能会出现很多的不一致状态。进程将不是一个整体，而线程也不能称为线程。</p>

<p>或许这也是为什么 LinuxThreads 虽然与 POSIX 的要求差距甚远，却能够存在，并且还被使用了好几年的原因吧。</p>

<p>但是， LinuxThreads 为了实现这个&#8221;第5点&#8221;，还是付出了很多代价，并且创造了 LinuxThreads 本身的一大性能瓶颈。</p>

<p>接下来要说说，为什么A程序创建了10个线程，但是ps时却会出现11个A进程了。因为 LinuxThreads 自动创建了一个管理线程，上面提到的&#8221;第5点&#8221;就是靠管理线程来实现的。</p>

<p>当程序开始运行时，并没有管理线程存在(因为尽管程序已经链接了 pthread 库，但是未必会使用多线程)。程序第一次调用 pthread_create 时， LinuxThreads 发现管理线程不存在，于是创建这个管理线程。这个管理线程是进程中的第一个线程(主线程)的儿子。</p>

<p>然后在 pthread_create 中，会通过前面提到的管道向管理线程发送一个命令，告诉它创建线程。即是说，除主线程外，所有的线程都是由管理线程来创建的，管理线程是它们的父亲。</p>

<p>于是，当任何一个子线程退出时，管理线程将收到 SIGUSER1 信号(这是在通过 clone 创建子线程时指定的)。管理线程在对应的 sig_handler 中会判断子线程是否正常退出，如果不是，则杀死所有线程，然后自杀。</p>

<p>那么，主线程怎么办呢？主线程是管理线程的父亲，其退出时并不会给管理线程发信号。于是，在管理线程的主循环中通过 getppid 检查父进程的ID号，如果ID号是1，说明父亲已经退出，并把自己托管给了 init 进程(1号进程)。这时候，管理线程也会杀掉所有子线程，然后自杀。</p>

<p>可见，线程的创建与销毁都是通过管理线程来完成的，于是管理线程就成了 LinuxThreads 的一个性能瓶颈。创建与销毁需要一次进程间通信，一次上下文切换之后才能被管理线程执行，并且多个请求会被管理线程串行地执行。</p>

<h4>LinuxThreads的不足</h4>

<p>由于Linux内核的限制以及实现难度等等原因，LinuxThreads并不是完全POSIX兼容的，在它的发行README中有说明。</p>

<p>（1）<strong>进程id问题</strong></p>

<p>这个不足是最关键的不足，引起的原因牵涉到 LinuxThreads 的&#8221;一对一&#8221;模型。Linux内核并不支持真正意义上的线程，LinuxThreads 是用与普通进程具有同样内核调度视图的轻量级进程来实现线程支持的。这些轻量级进程拥有独立的进程id，在进程调度、信号处理、IO等方面享有与普通进程一样的能力。</p>

<p>在源码阅读者看来，就是Linux内核的 <code>clone()</code> 没有实现对 <code>CLONE_PID</code> 参数的支持。在内核 <code>do_fork()</code> 中对 <code>CLONE_PID</code> 的处理是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PID</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
</span><span class='line'>                    <span class="k">goto</span> <span class="n">fork_out</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码表明，目前的Linux内核仅在pid为0的时候认可 CLONE_PID 参数，实际上，仅在 SMP 初始化，手工创建进程的时候才会使用 CLONE_PID 参数。</p>

<p>按照 POSIX 定义，同一进程的所有线程应该共享一个进程id和父进程id，这在目前的&#8221;一对一&#8221;模型下是无法实现的。</p>

<p>（2）<strong>信号处理问题</strong></p>

<p>由于异步信号是内核以进程为单位分发的，而 LinuxThreads 的每个线程对内核来说都是一个进程，且没有实现&#8221;线程组&#8221;，因此，某些语义不符合 POSIX 标准，比如没有实现向进程中所有线程发送信号，README对此作了说明。</p>

<p>如果核心不提供实时信号，LinuxThreads 将使用 SIGUSR1 和 SIGUSR2 作为内部使用的 restart 和 cancel 信号，这样应用程序就不能使用这两个原本为用户保留的信号了。在Linux kernel 2.1.60以后的版本都支持扩展的实时信号（从 <em>SIGRTMIN 到 </em>SIGRTMAX），因此不存在这个问题。</p>

<p>某些信号的缺省动作难以在现行体系上实现，比如 SIGSTOP 和 SIGCONT，LinuxThreads 只能将一个线程挂起，而无法挂起整个进程。</p>

<p>（3）<strong>线程总数问题</strong></p>

<p>LinuxThreads 将每个进程的线程最大数目定义为1024，但实际上这个数值还受到整个系统的总进程数限制，这又是由于线程其实是核心进程。</p>

<p>在kernel 2.4.x中，采用一套全新的总进程数计算方法，使得总进程数基本上仅受限于物理内存的大小，计算公式在kernel/fork.c的fork_init()函数中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">max_threads</span> <span class="o">=</span> <span class="n">mempages</span> <span class="o">/</span> <span class="p">(</span><span class="n">THREAD_SIZE</span><span class="o">/</span><span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span>
</span></code></pre></td></tr></table></div></figure>


<p>在i386上，THREAD_SIZE=2<em>PAGE_SIZE，PAGE_SIZE=2<sup>12</sup>（4KB），mempages=物理内存大小/PAGE_SIZE，对于256M的内存的机器，mempages=256</em>2<sup>20</sup>/2<sup>12</sup>=256*2<sup>8</sup>，此时最大线程数为4096。</p>

<p>但为了保证每个用户（除了root）的进程总数不至于占用一半以上物理内存，fork_init()中继续指定：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">init_task</span><span class="p">.</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">].</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="n">max_threads</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="n">init_task</span><span class="p">.</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">].</span><span class="n">rlim_max</span> <span class="o">=</span> <span class="n">max_threads</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些进程数目的检查都在do_fork()中进行，因此，对于LinuxThreads来说，线程总数同时受这三个因素的限制。</p>

<p>（4）<strong>管理线程问题</strong></p>

<p>管理线程容易成为瓶颈，这是这种结构的通病；同时，管理线程又负责用户线程的清理工作，因此，尽管管理线程已经屏蔽了大部分的信号，但一旦管理线程死亡，用户线程就不得不手工清理了，而且用户线程并不知道管理线程的状态，之后的线程创建等请求将无人处理。</p>

<p>（5）<strong>同步问题</strong></p>

<p>LinuxThreads 中的线程同步很大程度上是建立在信号基础上的，这种通过内核复杂的信号处理机制的同步方式，效率一直是个问题。</p>

<p>（6）<strong>其他POSIX兼容性问题</strong></p>

<p>Linux中很多系统调用，按照语义都是与进程相关的，比如nice、setuid、setrlimit等，在目前的 LinuxThreads 中，这些调用都仅仅影响调用者线程。</p>

<p>（7）<strong>实时性问题</strong></p>

<p>线程的引入有一定的实时性考虑，但 LinuxThreads 暂时不支持，比如调度选项，目前还没有实现。不仅 LinuxThreads 如此，标准的Linux在实时性上考虑都很少。</p>

<h3><strong>其他的线程机制</strong></h3>

<p>LinuxThreads 的问题，特别是兼容性上的问题，严重阻碍了Linux上的跨平台应用（如Apache）采用多线程设计，从而使得Linux上的线程应用一直保持在比较低的水平。在Linux社区中，已经有很多人在为改进线程性能而努力，其中既包括用户级线程库，也包括核心级和用户级配合改进的线程库。</p>

<p>很显然，为了改进 LinuxThread 必须得到内核的支持，并且需要重写线程库。为了实现这个需求，起先最为人看好的有两个项目，一个是 RedHat 公司牵头研发的 <strong><a href="http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">NPTL</a></strong>（Native Posix Thread Library），另一个则是 IBM 投资开发的 <strong>NGPT</strong>（Next Generation Posix Threading），二者都是围绕完全兼容 POSIX 1003.1c，同时在核内和核外做工作以而实现多对多线程模型。这两种模型都在一定程度上弥补了 LinuxThreads 的缺点，且都是重起炉灶全新设计的。</p>

<p>在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。</p>

<p>NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。</p>

<h4>NPTL</h4>

<p>NPTL实现了前面提到的POSIX的全部5点要求。但是，实际上，与其说是NPTL实现了，不如说是Linux内核实现了。</p>

<p>在Linux2.6中，内核有了线程组的概念，<code>task_struct</code> 结构中增加了一个 <code>tgid</code>(<code>threadgroupid</code>) 字段。如果这个task是一个&#8221;主线程&#8221;，则它的 <code>tgid</code> 等于 <code>pid</code>，否则 <code>tgid</code> 等于进程的 <code>pid</code> (即主线程的 <code>pid</code>)。在 <code>clone</code> 系统调用中，传递 <code>CLONE_THREAD</code> 参数就可以把新进程的 <code>tgid</code> 设置为父进程的 <code>tgid</code> (否则新进程的 <code>tgid</code> 会设为其自身的 <code>pid</code>)。</p>

<p>类似的 XXid 在 <code>task_struct</code> 中还有两个：<code>task-&gt;signal-&gt;pgid</code> 保存进程组的打头进程的 pid、<code>task-&gt;signal-&gt;session</code> 保存会话打头进程的 pid。通过这两个 id 来关联进程组和会话。</p>

<p>有了 tgid，内核或相关的 shell 程序就知道某个 tast_struct 是代表一个进程还是代表一个线程，也就知道在什么时候该展现它们，什么时候不该展现(比如在 ps 的时候，线程就不要展现了)。而 getpid(获取进程ID)系统调用返回的也是 tast_struct 中的 tgid，而 tast_struct 中的 pid 则由 gettid 系统调用来返回。</p>

<p>在执行ps命令的时候不展现子线程，也是有一些问题的。比如程序a.out运行时，创建了一个线程。假设主线程的pid是10001、子线程是10002（它们的tgid都是10001）。这时如果你kill10002，是可以把10001和10002这两个线程一起杀死的，尽管执行ps命令的时候根本看不到10002这个进程。如果你不知道Linux线程背后的故事，肯定会觉得遇到灵异事件了。</p>

<p>为了应付&#8221;发送给进程的信号&#8221;和&#8221;发送给线程的信号&#8221;，task_struc t里面维护了两套 <code>signal_pending</code>，一套是线程组共享的，一套是线程独有的。通过kill发送的信号被放在线程组共享的 signal_pending 中，可以由任意一个线程来处理；通过 <code>pthread_kill</code> 发送的信号( pthread_kill 是 pthread 库的接口，对应的系统调用 中tkill )被放在线程独有的 signal_pending 中，只能由本线程来处理。当线程停止/继续，或者是收到一个致命信号时，内核会将处理动作施加到整个线程组中。</p>

<p>NPTL的设计目标归纳可归纳为以下几点：</p>

<blockquote><ul>
<li>POSIX兼容性</li>
<li>SMP结构的利用</li>
<li>低启动开销</li>
<li>低链接开销（即不使用线程的程序不应当受线程库的影响）</li>
<li>与LinuxThreads应用的二进制兼容性</li>
<li>软硬件的可扩展能力</li>
<li>多体系结构支持</li>
<li>NUMA支持</li>
<li>与C++集成</li>
</ul>
</blockquote>

<p>在技术实现上，NPTL仍然采用1:1的线程模型，并配合glibc和最新的Linux Kernel2.5.x开发版在信号处理、线程同步、存储管理等多方面进行了优化。和LinuxThreads不同，NPTL没有使用管理线程，核心线程的管理直接放在核内进行，这也带了性能的优化。
主要是因为核心的问题，NPTL仍然不是100%POSIX兼容的，但就性能而言相对LinuxThreads已经有很大程度上的改进了。</p>

<p>除NPTL的1<em>1模型外还有一个m</em>n模型（NGPT就是），通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</p>

<hr />

<h2>写在后面</h2>

<p>这篇文章东拼西凑了很多资料，其中有很多地方并不是很理解，权当做一个粗浅的概览。通过这篇文章的整理，才发现自己以前对进程和线程的理解是多么的丢人，现在呢也只能算对其基本概念能有初步的认识，以后有需要的时候再作深入的学习。</p>

<p>其他一些参考，有一些还没看的，也先一起记录下来了：</p>

<ul>
<li><a href="http://wenku.baidu.com/link?url=MFJwqO1I6UdonzUo4OAFiIU4YYjJkXFrQRH3l4w0HIzjk_s1idNts4Cwhbj10T5UF_pAescBWXB9pQmsG9oSpLGpJWHvdB0f-UATkviQebmwiki/LinuxThreads">Linux线程浅析</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_69708ebe0100sqm0.html">Linux多线程编程</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/kernel/l-thread/">Linux线程实现机制分析</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/">通用线程：POSIX线程详解，第1部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/">通用线程：POSIX线程详解，第2部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/">通用线程：POSIX线程详解，第3部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-threading.html">Linux 线程模型的比较：LinuxThreads 和 NPTL</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/">Linux 多线程应用中如何编写安全的信号处理函数</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part1/">Posix线程编程指南(1)</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/">Posix线程编程指南(2)</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part3/">Posix线程编程指南(3)</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part4/">Posix线程编程指南(4)</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part5/">Posix线程编程指南(5)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机基础(一): 操作系统篇 -- 理解 Linux 进程状态及其转换]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-process-state/"/>
    <updated>2014-10-06T06:45:59+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/10/06/computer-science-basic-1-operating-system-process-state</id>
    <content type="html"><![CDATA[<h2>一、进程基本状态</h2>

<p>不同的操作系统对进程的状态解释不同，但是最基本的状态都是一样的。包括以下三种：</p>

<blockquote><ul>
<li><strong>执行态</strong>（Running）：进程占用CPU，并在CPU上运行；</li>
<li><strong>就绪态</strong>（Ready）：进程已经具备运行条件，但是CPU还没有分配过来；</li>
<li><strong>阻塞态</strong>（Blocked）：进程因等待某件事发生而暂时不能运行</li>
</ul>
</blockquote>

<!-- more -->


<p>进程在一生中，都处于上述3中状态之一。</p>

<p>理论上上述三种状态之间转换分为六种情况：</p>

<blockquote><ul>
<li><strong>执行->就绪</strong>：这是由调度引起的，主要是由于分配给进程CPU时间片用完</li>
<li><strong>就绪->执行</strong>：运行中的进程的时间片用完，调度就转到就绪队列中选择合适的进程（一般是优先级最高的进程）分配CPU</li>
<li><strong>执行->阻塞</strong>：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃CPU而处于阻塞状态，例如等待I/O完成、申请缓冲区不能满足、等待信号等</li>
<li><strong>阻塞->就绪</strong>：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</li>
</ul>
</blockquote>

<p>还有另外两种不会出现的状态转换：</p>

<blockquote><ul>
<li><strong>阻塞->执行</strong>：即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，其调度的选择对象为就绪队列</li>
<li><strong>就绪->阻塞</strong>：因为就绪态根本就没有执行，何来进入阻塞态？</li>
</ul>
</blockquote>

<hr />

<h2>二、Linux进程状态</h2>

<p>Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，为了对进程从产生到消亡的整个过程进行跟踪和描述，就需要定义进程的各种状态并制定相应的状态转换策略，以此来控制进程的运行。</p>

<p>Linux进程状态包括以下几种：</p>

<h3>1、<strong>可执行态</strong> R (TASK_RUNNING)</h3>

<p>这是执行态和就绪态的合并，表示进程正在运行或准备运行，Linux 中使用 <code>TASK_RUNNING</code> 宏表示此状态。</p>

<p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的 task_struct 结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。</p>

<p>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 <code>TASK_RUNNING</code> 状态。</p>

<h3>2、<strong>浅度睡眠态</strong> S (TASK_INTERRUPTIBLE)</h3>

<p>又称 <code>可中断的睡眠状态</code>，进程正在睡眠（被阻塞），等待资源到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。Linux 使用 <code>TASK_INTERRUPTIBLE</code> 宏表示此状态。</p>

<p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的 task_struct 结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p>

<p>通过 <code>ps</code> 命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于 TASK_INTERRUPTIBLE 状态（除非机器的负载很高）。毕竟CPU就这么几个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p>

<h3>3、<strong>深度睡眠态</strong> D (TASK_UNINTERRUPTIBLE)</h3>

<p>又称 <code>不可中断的睡眠状态</code>，其和浅度睡眠基本类似，但有一点就是不可被其他进程信号或时钟中断唤醒。Linux 使用 <code>TASK_UNINTERRUPTIBLE</code> 宏表示此状态。</p>

<p>与 <code>TASK_INTERRUPTIBLE</code> 状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。<code>不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号</code>。</p>

<blockquote><ul>
<li>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9 竟然杀不死一个正在睡眠的进程了！ 于是我们也很好理解，为什么 ps 命令看到的进程几乎不会出现 <code>TASK_UNINTERRUPTIBLE</code> 状态，而总是 <code>TASK_INTERRUPTIBLE</code> 状态。</li>
<li>而 <code>TASK_UNINTERRUPTIBLE</code> 状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/">《Linux内核中断内幕</a>》）</li>
<li>在进程对某些硬件进行操作时（比如进程调用 read 系统调用对某个设备文件进行读操作，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用 <code>TASK_UNINTERRUPTIBLE</code> 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的 <code>TASK_UNINTERRUPTIBLE</code> 状态总是非常短暂的，通过 ps 命令基本上不可能捕捉到。</li>
</ul>
</blockquote>

<p>Linux系统中也存在容易捕捉的 TASK_UNINTERRUPTIBLE 状态。执行 vfork 系统调用后，父进程将进入 TASK_UNINTERRUPTIBLE 状态，直到子进程调用 exit 或 exec （参见<a href="http://blog.sina.com.cn/s/blog_5eb8ebcb0100rp56.html">《神奇的vfork》</a>）。</p>

<p>通过下面的代码就能得到处于 <code>TASK_UNINTERRUPTIBLE</code> 状态的进程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include&lt;unistd.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">vfork</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译运行，然后 ps 一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ps -ax <span class="p">|</span> grep a.out
</span><span class='line'><span class="m">4371</span> pts/0    D+     0:00 ./a.out
</span><span class='line'><span class="m">4372</span> pts/0    S+     0:00 ./a.out
</span><span class='line'><span class="m">4374</span> pts/1    S+     0:00 grep a.out
</span></code></pre></td></tr></table></div></figure>


<p>然后我们可以试验一下 <code>TASK_UNINTERRUPTIBLE</code> 状态的威力。不管kill还是kill -9，这个 <code>TASK_UNINTERRUPTIBLE</code> 状态的父进程依然屹立不倒。</p>

<h3>4、<strong>暂停态</strong> T (TASK_STOPPED or TASK_TRACED)</h3>

<p>又称暂停状态或跟踪状态，进程暂停执行接受某种处理。如正在接受调试的进程处于这种状态，Linux 使用 <code>TASK_STOPPED</code> 宏表示此状态。</p>

<p>向进程发送一个 <code>SIGSTOP</code> 信号，它就会因响应该信号而进入 TASK_STOPPED 状态（除非该进程本身处于 TASK_UNINTERRUPTIBLE 状态而不响应信号）。（ SIGSTOP 与 SIGKILL 信号一样，是非常强制的。不允许用户进程通 过signal 系列的系统调用重新设置对应的信号处理函数。）</p>

<p>向进程发送一个 <code>SIGCONT</code> 信号，可以让其从 TASK_STOPPED 状态恢复到 TASK_RUNNING 状态。</p>

<p>当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在 gdb 中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>

<p>对于进程本身来说，TASK_STOPPED 和 TASK_TRACED 状态很类似，都是表示进程暂停下来。而 TASK_TRACED 状态相当于在 TASK_STOPPED 之上多了一层保护，处于 TASK_TRACED 状态的进程不能响应 SIGCONT 信号而被唤醒。只能等到调试进程通过 ptrace 系统调用执行 PTRACE_CONT、PTRACE_DETACH 等操作（通过 ptrace 系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复 TASK_RUNNING 状态。</p>

<h3>5、<strong>退出状态-僵死态</strong> Z (TASK_DEAD – EXIT_ZOMBIE)</h3>

<p>又称退出状态，进程已经结束但未释放PCB，进程成为僵尸进程，Linux 使用 <code>EXIT_ZOMBIE</code> 宏表示此状态。</p>

<p>进程在退出的过程中，处于 TASK_DEAD 状态。</p>

<p>在这个退出过程中，进程占有的所有资源将被回收，除了 task_struct 结构（以及少数资源）以外。于是进程就只剩下 task_struct 这么个空壳，故称为僵尸。</p>

<p>之所以保留 task_struct，是 <strong>因为</strong> task_struct 里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在 shell 中，<code>$?</code> 变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为 if 语句的判断条件。当然，内核也可以将这些信息保存在别的地方，而将 task_struct 结构释放掉，以节省一些空间。但是使用 task_struct 结构更为方便，因为在内核中已经建立了从 pid 到 task_struct 的查找关系，还有进程间的父子关系。释放掉 task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>

<p>父进程可以通过 wait 系列的系统调用（如 wait4、waitid ）来等待某个或某些子进程的退出，并获取它的退出信息。然后 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是 SIGCHLD ，但是在通过 clone 系统调用创建子进程时，可以设置这个信号。</p>

<p>通过下面的代码能够制造一个 EXIT_ZOMBIE 状态的进程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include&lt;unistd.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="n">fork</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="n">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译运行，然后 ps 一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ps -ax <span class="p">|</span> grep a.out
</span><span class='line'><span class="m">10410</span> pts/0    S+     0:00 ./a.out
</span><span class='line'><span class="m">10411</span> pts/0    Z+     0:00 <span class="o">[</span>a.out<span class="o">]</span>
</span><span class='line'><span class="m">10413</span> pts/1    S+     0:00 grep a.out
</span></code></pre></td></tr></table></div></figure>


<p>只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？</p>

<p>当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。</p>

<p>1号进程，pid为1的进程，又称 <code>init 进程</code>：</p>

<p>Linux 系统启动后，第一个被创建的用户态进程就是 init 进程。它有两项使命：
（1）执行系统初始化脚本，创建一系列的进程（它们都是 init 进程的子孙）；
（2）在一个死循环中等待其子进程的退出事件，并调用 waitid 系统调用来完成“收尸”工作；</p>

<p>init 进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于 TASK_INTERRUPTIBLE 状态，“收尸”过程中则处于 TASK_RUNNING 状态。</p>

<h3>6、<strong>退出状态</strong> X (TASK_DEAD – EXIT_DEAD)</h3>

<p>而进程在退出过程中也可能 <code>不会保留</code> 它的 task_struct 。比如这个进程是多线程程序中被 detach 过的进程（进程？线程？参见<a href="http://wenku.baidu.com/link?url=fMmb8NKSH9tolCwBh50f4ocE-bmlMuo0_J5_-V9_djN1sdm0n2XzQcf8zkUF0IBNeGHMwM9KUHBCXOs0qldPOqce9ycaYFuiCLFdSP4B7vi">《linux线程浅析》</a>）。或者父进程通过设置 SIGCHLD 信号的 handler 为 SIG_IGN，显式的忽略了 SIGCHLD 信号。（这是 posix 的规定，尽管子进程的退出信号可以被设置为 SIGCHLD 以外的其他信号。）此时，进程将被置于 EXIT_DEAD 退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以 EXIT_DEAD 状态是非常短暂的，几乎不可能通过 ps 命令捕捉到。</p>

<hr />

<h2>三、<strong>Linux 进程的初始状态</strong></h2>

<p>进程是通过 fork 系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过 kernel_thread 函数创建内核进程。</p>

<p>这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）</p>

<p>那么既然调用进程处于 TASK_RUNNING 状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于 TASK_RUNNING 状态。</p>

<p>另外，在系统调用调用 clone 和内核函数 kernel_thread 也接受 CLONE_STOPPED 选项，从而将子进程的初始状态置为 TASK_STOPPED 。</p>

<hr />

<h2>四、<strong>Linux 进程状态变迁</strong></h2>

<p>进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向：从 <code>TASK_RUNNING状态</code> 变为 <code>非TASK_RUNNING状态</code> 、或者从 <code>非TASK_RUNNING状态</code> 变为 <code>TASK_RUNNING状态</code>。</p>

<p>也就是说，如果给一个 TASK_INTERRUPTIBLE 状态的进程发送 SIGKILL 信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应 SIGKILL 信号而退出（变为TASK_DEAD状态）。并不会从 TASK_INTERRUPTIBLE 状态直接退出。</p>

<p>进程从非 TASK_RUNNING 状态变为 TASK_RUNNING 状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为 TASK_RUNNING ，然后将其 task_struct 结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。</p>

<p>而进程从 TASK_RUNNING 状态变为非 TASK_RUNNING 状态，则有两种途径：</p>

<blockquote><ul>
<li>响应信号而进入 TASK_STOPED 状态、或 TASK_DEAD 状态；</li>
<li>执行系统调用主动进入 TASK_INTERRUPTIBLE 状态（如 nanosleep 系统调用）、或 TASK_DEAD 状态（如 exit 系统调用）；或由于执行系统调用需要的资源得不到满足，而进入 TASK_INTERRUPTIBLE 状态或 TASK_UNINTERRUPTIBLE 状态（如 select 系统调用）。</li>
</ul>
</blockquote>

<p>显然，这两种情况都只能发生在进程正在CPU上执行的情况下。</p>

<p>以上关于Linux进程及其状态转换的描述，可参考下图的总结：</p>

<p><span class='caption-wrapper'><img class='caption' src='http://RonnieTsang.github.io/images/computer-science-basic-1-operating-system-process-state-1.jpg' width='' height='' title='Linux进程状态及其转换'><span class='caption-text'>Linux进程状态及其转换</span></span></p>

<hr />

<p>Reference:</p>

<p>  1、<a href="http://blog.csdn.net/huzia/article/details/18946491">http://blog.csdn.net/huzia/article/details/18946491</a>
  2、<a href="http://blog.chinaunix.net/uid-26126915-id-2948970.html">http://blog.chinaunix.net/uid-26126915-id-2948970.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么每一个C程序员都应该学学Erlang]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/10/03/why-should-c-programmers-learn-erlang/"/>
    <updated>2014-10-03T09:51:04+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/10/03/why-should-c-programmers-learn-erlang</id>
    <content type="html"><![CDATA[<p>这是一篇翻译文章，原文<a href="http://tchen.me/posts/2013-07-22-why-should-c-programmers-learn-erlang.html">在此</a>。水平有限，见笑了。</p>

<p>2013年底初接触 <a href="http://www.erlang.org/">Erlang</a> ，真的被她震撼到了！虽然一开始很不习惯其语法和变量只能绑定不能改变值等各种新奇的东西，写起代码来也很别扭，但是通过一天的接触学习，毫不夸张地说，我爱上她了。</p>

<p>你要问为什么？
爱难道需要理由吗？当然要，翻译这篇文章，就是为了回答这个问题！</p>

<!-- more -->


<p>很可惜的是，后来由于各种原因包括工作变动，并没有继续深入学习使用过 Erlang ，仅以此文，开启重新学习 Erlang 的计划！</p>

<p>以下是正文：</p>

<hr />

<h1>前言</h1>

<p>如果有人跳出来说一种语言比另一种语言好，通常这将引发这两个语言阵营之间一场激烈的争论。一旦你使用某种语言很长时间，你会成为她的狂热粉丝，并不自觉地试图去捍卫她。不管你承不承认，（此时的）你已经跳入了一个陷阱，你所能看到的东西被极大地限制了（，变得狭隘）。</p>

<p>对此，《肖生克的救赎》给出了很好地注解：
<img src="http://tchen.me/assets/files/snapshots/institutionalized.jpg" alt="The Shawshank Redemption" /></p>

<blockquote><ul>
<li>[Red] 这些墙很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就叫体制化。</li>
</ul>
</blockquote>

<p>所以趁着在体制化的泥潭中还没有陷得太深，让我们尝点新鲜的玩意儿吧———学习一门 C 家族以外的语言，一门带你进入全新领域的语言。</p>

<p>对，<code>Erlang</code> 看起来是个很不错的选择！</p>

<hr />

<h1>为什么是 Erlang ?</h1>

<p>Erlang 最初由 Ericsson 公司为了其“下一代”交换机而开发出来的，已经有了 20 多年的历史（诞生于 1987 年，1998 年开源）。</p>

<p>Erlang 以 <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a> 语言为基础，加入了 <a href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程</a> 的特性，加之其难以理解的语法，使她看起来真是一门古怪的语言。</p>

<p>然而，Erlang 这门语言融合了几乎最优秀的设计哲学，（她的设计思想）领先当今时代至少 10 年。</p>

<p>（真这么牛逼？）容我慢慢道来。</p>

<h2>几乎无副作用</h2>

<p>作为一门函数语言， Erlang 摒弃了 <code>共享状态</code> 的概念。变量只能被 <code>绑定</code>，（一旦完成绑定，变量的值就）不能被改变。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>1&gt; <span class="nv">X</span> <span class="o">=</span> 1.
</span><span class='line'>1
</span><span class='line'>2&gt; <span class="nv">X</span> <span class="o">=</span> X + 1.
</span><span class='line'>** exception error: no match of right hand side value 2
</span><span class='line'>3&gt; <span class="nv">X</span> <span class="o">=</span> 2.
</span><span class='line'>** exception error: no match of right hand side value 2
</span></code></pre></td></tr></table></div></figure>


<p>这保证了你能写出没有副作用的函数，也就是说，用相同的参数多次调用一个函数，返回值是一样的。这是 Erlang 一个很重要的优点，它带来的好处是：</p>

<blockquote><ul>
<li><strong>你（几乎）不需要去保护所谓的 <code>临界区</code>。</strong> 想一想并发环境下的 C 代码，你需要使用若干 <code>同步原语</code> 来保护数据不被破坏。糟糕的同步实现还会给系统带来底下的性能和不稳定性。这是让很多 C 程序员头疼的地方。</li>
<li><strong>底层优化变得容易。</strong> 因为编译器知道一个变量一旦完成绑定将不再改变，它可以对寄存器的使用采用相当激进的优化策略。</li>
<li><strong>垃圾回收变得容易。</strong> 可怜的 Java 虚拟机，为了确定一个变量是否可回收可没那么轻松，因为它可能被别的变量所引用，可能还会被使用或者改变。Erlang 不同，一个变量的作用域仅在当前函数，没有其他的代码会访问到它，更别说改变它的值了。(感兴趣的话，可以进一步了解一下 <a href="http://stackoverflow.com/questions/10221907/garbage-collection-and-memory-management-in-erlang">Erlang 的垃圾收集和内存管理</a>。)</li>
</ul>
</blockquote>

<h2>内建的 异步/并发 机制</h2>

<p>Erlang 内建了对 <code>并发/异步</code> 机制的支持，其背后的思想是 <a href="http://en.wikipedia.org/wiki/Actor_model">Actor 模式</a>。在 1986 年的时候，在那个 <code>多核</code>，<code>多线程</code>，甚至 <code>SMP</code>（对称多处理）这些术语还不为人所知的年代，这是多么富有远见的创造啊！</p>

<h3>轻量级进程</h3>

<p>为了支持并发，Erlang 在她的虚拟机中创建自己的轻量级进程。</p>

<blockquote><ul>
<li>你可以同时创建 <code>上百万</code> 个进程，也不会有操作系统资源瓶颈的问题。</li>
<li>并且，进程的创建是如此快速———在奔腾4 CPU上这个速度是 350,000 个/每秒。</li>
<li>Erlang 进程占用的内存资源也非常小——仅在 KB 的粒度（最小可达到约300字节）。操作系统层次的进程动辄 MB 的粒度</li>
<li>进程调度方面，Erlang 支持 <a href="http://en.wikipedia.org/wiki/Real-time_computing#Soft">软实时</a> 调度。并且 上下文切换 的代价非常小——在现代处理器上，Erlang 进程间切换仅需要 <code>16</code> 个指令周期和 <code>20</code> 纳秒（<a href="http://stackoverflow.com/questions/2708033/technically-why-are-processes-in-erlang-more-efficient-than-os-threads">参考</a>）。如果你对进程调度感兴趣，可参阅 <a href="http://jlouisramblings.blogspot.com/2013/01/how-Erlang-does-scheduling.html">Erlang 如何调度</a>。</li>
</ul>
</blockquote>

<h3>消息传递</h3>

<p>Erlang 使用 <code>消息传递</code> 来进行 <code>进程间通信</code>，这是继承自 Actor 模式 的方法。
每个 Erlang 进程都有用来存储传入 <code>消息</code> 的 <code>信箱</code>。
得益于内建进程和进程间的消息传递等机制， Erlang 是完全异步的。</p>

<h4>实例</h4>

<p><code>代码</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">echo_server</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">rpc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">loop</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">rpc</span><span class="p">(</span><span class="nv">Pid</span><span class="p">,</span> <span class="nv">Request</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">Pid</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="nv">Request</span><span class="p">},</span>
</span><span class='line'>    <span class="k">receive</span>
</span><span class='line'>        <span class="nv">Response</span> <span class="o">-&gt;</span>
</span><span class='line'>            <span class="nv">Response</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="nf">loop</span><span class="p">()</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">receive</span>
</span><span class='line'>        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="p">{</span><span class="n">message</span><span class="p">,</span> <span class="nv">Message</span><span class="p">}}</span> <span class="o">-&gt;</span>
</span><span class='line'>            <span class="nv">From</span> <span class="o">!</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Message</span><span class="p">},</span>
</span><span class='line'>            <span class="n">loop</span><span class="p">();</span>
</span><span class='line'>        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="nv">Request</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>            <span class="nv">From</span> <span class="o">!</span> <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="nv">Request</span><span class="p">},</span>
</span><span class='line'>            <span class="n">loop</span><span class="p">()</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>命令行执行</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>1&gt; c<span class="o">(</span>echo_server<span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,echo_server<span class="o">}</span>
</span><span class='line'>2&gt; <span class="nv">Pid</span> <span class="o">=</span> spawn<span class="o">(</span>fun echo_server:loop/0<span class="o">)</span>.
</span><span class='line'>&lt;0.42.0&gt;
</span><span class='line'>3&gt; echo_server:rpc<span class="o">(</span>Pid, <span class="o">{</span>message, <span class="s2">&quot;Hello world!&quot;</span><span class="o">})</span>.
</span><span class='line'><span class="o">{</span>ok,<span class="s2">&quot;Hello world!&quot;</span><span class="o">}</span>
</span><span class='line'>4&gt; echo_server:rpc<span class="o">(</span>Pid, <span class="o">{</span>message1, <span class="s2">&quot;Hello world!&quot;</span><span class="o">})</span>.
</span><span class='line'><span class="o">{</span>error,<span class="o">{</span>message1,<span class="s2">&quot;Hello world!&quot;</span><span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>希望你没被上面这些语法和函数式编程的语句吓到。我不打算对代码细节进行展开，简单点说，这段代码创建了一个回显服务器，并向该服务器发送消息。</p>

<p>使用 <code>spawn</code>，<code>!</code>(消息传递关键字) 和 <code>receive</code>，我们仅用几行代码就完成了服务端的创建。对比一下，在 C，Java，Python，Ruby 或者 node.js 中如何完成相同的任务，你就会发现 Erlang 是多么的优雅！</p>

<p><code>Actor</code> 模式对于 <code>并发</code> 是如此的重要，以至于一些现代的语言比如 <a href="http://golang.org/">Golong</a> 也在语言层面上对它进行支持。我对 Golang 并不熟悉，但是（我知道）它允许共享内存，因此在 Golang 中进行并发编程可能仍然需要同步的工作。并且，我认为 Golang 并不支持软实时，因为这是 Erlang 的设计目标而非 Golang 的。</p>

<p>诸如 Java，Python 和 Rudy 等其他语言，则使用 <code>库</code> 的方式对 Actor 模式进行支持。对其 <code>效率</code> 我持质疑的态度。只有把 <code>协程</code> 及其 <code>调度</code> 放到 <code>虚拟机</code> 层面，你才能获得最好的性能。（这段话不甚理解，mark）</p>

<h2>可扩展性</h2>

<p>从前面的例子可以看出在 Erlang 里我们的代码看起来结构相对松散些（是这个意思不？）。加上内建的并发支持，Erlang 应用程序相当容易扩展。你可以从一个节点将代码分发到多个节点，分发到局域网内多台机器上，甚至分发到其他网络的服务器上，而只需要额外一点点代码。这是因为：</p>

<blockquote><ul>
<li>Erlang 允许你在远程节点上创建进程</li>
<li>Erlang 允许你用如同跟本地进程交互一样的方式，与远程进程进行交互</li>
</ul>
</blockquote>

<p>对前面的程序稍加改动 (添加一个函数), 我们就能够将其分发到 2 个 Erlang 节点上去：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">start</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">register</span><span class="p">(</span><span class="o">?</span><span class="nv">MODULE</span><span class="p">,</span> <span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span> <span class="n">loop</span><span class="o">/</span><span class="mi">0</span><span class="p">)).</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>➜  Erlang-programming-examples  erl -sname weasley
</span><span class='line'>Erlang R16B <span class="o">(</span>erts-5.10.1<span class="o">)</span> <span class="o">[</span><span class="nb">source</span><span class="o">]</span> <span class="o">[</span>64-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>async-threads:10<span class="o">]</span> <span class="o">[</span>hipe<span class="o">]</span> <span class="o">[</span>kernel-poll:false<span class="o">]</span> <span class="o">[</span>dtrace<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>Eshell V5.10.1  <span class="o">(</span>abort with ^G<span class="o">)</span>
</span><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>1&gt; c<span class="o">(</span>echo_server<span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,echo_server<span class="o">}</span>
</span><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>2&gt; echo_server:start<span class="o">()</span>.
</span><span class='line'><span class="nb">true</span>
</span><span class='line'>
</span><span class='line'>➜  Erlang-programming-examples  erl -sname potter
</span><span class='line'>Erlang R16B <span class="o">(</span>erts-5.10.1<span class="o">)</span> <span class="o">[</span><span class="nb">source</span><span class="o">]</span> <span class="o">[</span>64-bit<span class="o">]</span> <span class="o">[</span>smp:8:8<span class="o">]</span> <span class="o">[</span>async-threads:10<span class="o">]</span> <span class="o">[</span>hipe<span class="o">]</span> <span class="o">[</span>kernel-poll:false<span class="o">]</span> <span class="o">[</span>dtrace<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>Eshell V5.10.1  <span class="o">(</span>abort with ^G<span class="o">)</span>
</span><span class='line'><span class="o">(</span>potter@cnrd-tchen-mbp<span class="o">)</span>1&gt; rpc:call<span class="o">(</span><span class="s1">&#39;weasley@cnrd-tchen-mbp&#39;</span>, echo_server, rpc, <span class="o">[{</span>message, <span class="s2">&quot;Hurry up, Harry!&quot;</span><span class="o">}])</span>.
</span><span class='line'><span class="o">{</span>ok,<span class="s2">&quot;Hurry up, Harry!&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>热更新</h2>

<p>这是每个系统程序员梦寐以求的特性啊！看看你为客户提供的那些实现起来单调乏味的所谓 <code>热补丁</code> 的解决方案，不断的删改，看起来又很不得体，有着很大的局限性。但是 Erlang 正好相反，她yi yi zhongsupports hot code reload in an elegant manner.</p>

<p>沿用前面的例子，我们通过修改一点代码以便待会能够动态更新运行中的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">echo_server_general</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">rpc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">swap_code</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">start</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nb">register</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">loop</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">)</span> <span class="k">end</span><span class="p">)).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">swap_code</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">rpc</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="p">{</span><span class="n">swap_code</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">}).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">rpc</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Request</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">Name</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="nv">Request</span><span class="p">},</span>
</span><span class='line'>    <span class="k">receive</span>
</span><span class='line'>        <span class="p">{</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Response</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nv">Response</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="nf">loop</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">receive</span>
</span><span class='line'>        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="p">{</span><span class="n">swap_code</span><span class="p">,</span> <span class="nv">NewMod</span><span class="p">}}</span> <span class="o">-&gt;</span>
</span><span class='line'>            <span class="nv">From</span> <span class="o">!</span> <span class="p">{</span><span class="nv">Name</span><span class="p">,</span> <span class="n">ack</span><span class="p">},</span>
</span><span class='line'>            <span class="n">loop</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">NewMod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="nv">Request</span><span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>            <span class="nv">Response</span>  <span class="o">=</span> <span class="nv">Mod</span><span class="p">:</span><span class="nf">handle</span><span class="p">(</span><span class="nv">Request</span><span class="p">),</span>
</span><span class='line'>            <span class="nv">From</span> <span class="o">!</span> <span class="p">{</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Response</span><span class="p">},</span>
</span><span class='line'>            <span class="n">loop</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Mod</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">echo_server</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">echo</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">handle</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">echo</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Message</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">echo_server_general</span><span class="p">:</span><span class="nf">rpc</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="p">{</span><span class="n">echo</span><span class="p">,</span> <span class="nv">Message</span><span class="p">}).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">handle</span><span class="p">({</span><span class="n">echo</span><span class="p">,</span> <span class="nv">Message</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Message</span><span class="p">}.</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>1&gt; echo_server_general:start<span class="o">(</span>s, echo_server<span class="o">)</span>.
</span><span class='line'><span class="nb">true</span>
</span><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>2&gt; echo_server:echo<span class="o">(</span>s, <span class="s2">&quot;hello world&quot;</span><span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,<span class="s2">&quot;hello world&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在新需求来了——回显服务器需要把消息的首字母转换成大写形式再回显发送。一般情况下，我们需要停掉服务器程序，替换代码，然后重启服务器。但在 Erlang 中，不需要这么麻烦。</p>

<p>代码修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">echo_server</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">echo</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">handle</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">echo</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Message</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">echo_server_general</span><span class="p">:</span><span class="nf">rpc</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="p">{</span><span class="n">echo</span><span class="p">,</span> <span class="nv">Message</span><span class="p">}).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">handle</span><span class="p">({</span><span class="n">echo</span><span class="p">,</span> <span class="nv">Message</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="n">capfirst</span><span class="p">(</span><span class="nv">Message</span><span class="p">)}.</span>
</span><span class='line'>
</span><span class='line'><span class="nf">capfirst</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="k">when</span> <span class="nv">H</span> <span class="o">&gt;=</span> <span class="sc">$a</span><span class="p">,</span> <span class="nv">H</span> <span class="o">=&lt;</span> <span class="sc">$z</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">H</span> <span class="o">+</span> <span class="p">(</span><span class="sc">$A</span> <span class="o">-</span> <span class="sc">$a</span><span class="p">)|</span><span class="nv">T</span><span class="p">];</span>
</span><span class='line'><span class="nf">capfirst</span><span class="p">(</span><span class="nv">Others</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Others</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>4&gt; c<span class="o">(</span>echo_server<span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,echo_server<span class="o">}</span>
</span><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>5&gt; echo_server_general:swap_code<span class="o">(</span>s, echo_server<span class="o">)</span>.
</span><span class='line'>ack
</span><span class='line'><span class="o">(</span>weasley@cnrd-tchen-mbp<span class="o">)</span>6&gt; echo_server:echo<span class="o">(</span>s, <span class="s2">&quot;hello world&quot;</span><span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,<span class="s2">&quot;Hello world&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>热更新的特性不仅对于有着高可用性要求的服务非常有用，对于软件的开发生命周期同样很有帮助。你不需要浪费许多时间在停服，更新程序，然后重启这种事情上，而且有时候仅仅只是更新了很少量的几行代码而已。</p>

<p>我看过几篇声称热更新在现实中并不是很有用的文章，他们担心热更新的方式会带来模块版本管理上的混乱。这是可以理解的，人们对于未知的事物，对于超出其知识范围和视野的事物，总会有恐惧心理的。（我相信）10年以后，当有相应的软件管理工具和理论问世以后，热更新的强大之处将会彰显出来。（我只能说）Erlang 是如此的前卫，以致于在她问世 20 多年之后，她的设计哲学仍然领先于当今时代。</p>

<h2>容错机制</h2>

<p>高达 <code>nine nines</code>（99.9999999%）的系统可用性是软件工业一直在追求的目标。然后，人总是会犯错的，其创造出来的软件当然也免不了出错。<code>墨菲法则</code> 说，任何可能出错的事终将出错。认识到我们终将无法避免错误，那么最重要的问题就是：软件如何健壮地应对错误（并继续正常运作）？</p>

<p>其他的一些语言鼓励程序员使用防御性的编程策略来保证程序不致因为某些错误而奔溃，但 Erlang 的思想则是 “<code>让它奔溃吧</code>” ！这是为何？</p>

<p>如果为你建造的房子是这样的，只要某个窗户坏掉了整栋房子就会倒塌，你会住进去吗？答案是显而易见的！你需要的房子应该在这种情况下仍然可以安全居住，稍后叫人来修窗户就行了。</p>

<p>这就是用 C 和 Erlang 编写的程序之间的区别。只要知道如何从错误中恢复，软件出错就不是一个多么严重的问题了。在 Erlang 里：</p>

<blockquote><ul>
<li>一个进程的奔溃不会影响到其他不相关的进程</li>
<li>一个进程出错以后在退出前，会向与它关联的进程发送通知（hey，我要退出了！）</li>
<li>可以使用监控者来恢复奔溃的程序，比如重启进程。</li>
</ul>
</blockquote>

<h2>速度</h2>

<p>与 C 语言相比，Erlang 代码在性能上有几点劣势：</p>

<blockquote><ul>
<li>代码运行于虚拟机之上</li>
<li>运行时类型推导</li>
<li>模式匹配</li>
<li>其他&hellip;</li>
</ul>
</blockquote>

<p>那么 Erlang 到底有多慢？参考<a href="http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-Erlang-vs-haskell">这篇文章</a>，我在自己的mbp上做了如下测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>➜  comparison  <span class="nb">time</span> ./euler12.bin
</span><span class='line'>842161320
</span><span class='line'>./euler12.bin  5.90s user 0.01s system 99% cpu 5.910 total
</span><span class='line'>➜  comparison  <span class="nb">time </span>erl -noshell -s euler12 solve
</span><span class='line'>842161320
</span><span class='line'>erl -noshell -s euler12 solve  11.09s user 0.19s system 100% cpu 11.269 total
</span><span class='line'>➜  comparison  <span class="nb">time </span>pypy euler12.py
</span><span class='line'>842161320
</span><span class='line'>pypy euler12.py  9.92s user 0.05s system 96% cpu 10.305 total
</span><span class='line'>➜  comparison  <span class="nb">time</span> ./euler12.py
</span><span class='line'>842161320
</span><span class='line'>./euler12.py  66.32s user 0.04s system 99% cpu 1:06.43 total
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，C 代码几乎比 Erlang 快了 1 倍。（但是）考虑到 Erlang 带来的好处，这已经是很不错的数据了。想想 （Erlang 所擅长的）I/O 密集型、并发/分布式场景，Erlang 毫无疑问地胜出了。</p>

<p>虽然现在 Erlang 在性能上无法超越 C，但将来单个芯片裸片（DIE）上有成百上千个核的时候，这一天会到来的。</p>

<h2>应用</h2>

<p>有不少著名的软件是基于 Erlang 开发的：</p>

<blockquote><ul>
<li><a href="http://couchdb.apache.org/">CouchDB</a>. 一个 NoSql 数据库。</li>
<li><a href="http://www.rabbitmq.com/">RabbitMQ</a>. 一个分布式消息队列系统。</li>
<li><a href="http://www.ejabberd.im/">ejabberd</a>. 一个即时通信服务器。</li>
<li><a href="http://www.adelcogroup.com/EricssonAXD301.htm">AXD301 ATM switch</a>. 这很可能是世界上唯一一个能够达到 <code>nine nines</code> 可用性的系统了，它已经连续正常运行了超过 20 年！</li>
<li>还有很多其他的公司，包括 <code>Amazon</code>, <code>Facebook</code>, <code>Yahoo!</code>, <code>T-Mobile</code> 等，都在他们的系统中使用了 Erlang，参考 <a href="http://stackoverflow.com/questions/1636455/where-is-Erlang-used-and-why">Where is Erlang used and why?</a></li>
</ul>
</blockquote>

<hr />

<h1>如何学习 Erlang</h1>

<p>Erlang 学习起来确实相当困难，但是一旦你掌握了她，你就是 <code>the king</code>。我很欣赏下面这段话，摘自著名 Erlang Web MVC 框架 <a href="http://www.chicagoboss.org/ng-used-and-why">Chicago Boss</a> 的作者 Evan Miller 撰写的一篇名为 <a href="http://www.evanmiller.org/joy-of-erlang.html">Joy of erlang</a> 的文章：</p>

<blockquote><ul>
<li>In the movie Avatar, there&rsquo;s this big badass bird-brained pterodactyl thing called a Toruk that the main character must learn to ride in order to regain the trust of the blue people. As a general rule, Toruks do not like to be ridden, but if you fight one, subdue it, and then link your Blue Man ponytail to the Toruk&rsquo;s ptero-tail, you get to own the thing for life. Owning a Toruk is awesome; it&rsquo;s like owning a flying car you can control with your mind, which comes in handy when battling large chemical companies, impressing future colleagues, or delivering a pizza. But learning to ride a Toruk is dangerous, and very few people succeed.</li>
</ul>
</blockquote>

<p><img src="http://tchen.me/assets/files/snapshots/toruk.jpg" alt="阿凡达" /></p>

<p>这段话生动地反映了我学习 Erlang 的困难程度。顺便说一句，我距离攻克她还远着呢～～～</p>

<p>在学习 Erlang 之前，我熟练掌握了 C、Python 和 Javascript，对 C++、Java 和 Ruby 也有所涉略。我的思维也是早已习惯了命令式编程，因此最大的挑战就是要去适应函数式编程，这需要做出思维上巨大的转变。</p>

<h2>变量不变</h2>

<p>变量只能绑定某个值，而无法更改，这让我突然间不会编程了！
举个例子，要求在不使用任何辅助函数（例如map）的情况下实现 upper(str) 函数。</p>

<p>在 Python 中这简直太简单且直接了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='py'><span class='line'><span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
</span><span class='line'>    <span class="n">str1</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
</span><span class='line'>        <span class="n">str1</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">str1</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是在 Erlang 中，无法改变变量的值，该如何实现呢？
诀窍在于一个累积器的概念，下面这个范例，请在以后编写 Erlang 程序的时候时刻记着。代码看起来是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">upper</span><span class="p">(</span><span class="nv">S</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">upper</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="p">[]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">upper</span><span class="p">([],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="nn">lists</span><span class="p">:</span><span class="nf">reverse</span><span class="p">(</span><span class="nv">N</span><span class="p">);</span>
</span><span class='line'><span class="nf">upper</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">H</span> <span class="o">&gt;</span> <span class="sc">$a</span><span class="p">,</span> <span class="nv">H</span> <span class="o">=&lt;</span> <span class="sc">$z</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">upper</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span> <span class="o">+</span> <span class="p">(</span><span class="sc">$A</span> <span class="o">-</span> <span class="sc">$a</span><span class="p">)|</span><span class="nv">N</span><span class="p">]);</span>
</span><span class='line'><span class="nf">upper</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">upper</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">N</span><span class="p">]).</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数本身不包含任何内部变量的状态改变，但我们使用一个通过参数传入的累积器，实现了同样的功能。这是函数式编程里面的一个很基础的范例，理解并记住它，要么请放弃 Erlang。</p>

<h2>模式匹配</h2>

<p>模式匹配使得 Erlang 程序看起来既优雅又易于理解。</p>

<p>在 C 语言中，一个函数在它的作用域中必须是唯一的，你不能定义了一个函数 <code>fun(x)</code>，再定义一个函数 <code>fun(x,y)</code>，但在 Erlang 中就没有这个限制了。你可以随意定义多个（同名）函数，只要它们的参数是不一样的，你也可以为一个函数定义多个子句，只要它们匹配的模式不同。</p>

<p>仍旧以上面的 <code>upper()</code> 函数为例，调用 <code>upper("#hello")</code> 时:</p>

<blockquote><ul>
<li>由于只有一个参数，该调用匹配 <code>upper(S)</code>，因此接着调用 <code>upper("#hello", [])</code></li>
<li><code>"#hello"</code> 不匹配 <code>[]</code>，并且第一个字符  <code>"#"</code> 不匹配 guard 条件，故调用 <code>upper("#hello", [])</code> 匹配 <code>upper([H|T], N)</code>，因此接着调用 <code>upper("hello", [$#])</code></li>
<li>接下来的各个调用匹配 <code>upper([H|T], N) when H &gt; $a, H =&lt; $z</code>，每个调用将一个字符转换为大写，调用序列为：</li>
</ul>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">upper</span><span class="p">(</span><span class="s">&quot;ello&quot;</span><span class="p">,</span> <span class="p">[</span><span class="sc">$H</span><span class="p">,</span> <span class="sc">$#</span><span class="p">])</span>
</span><span class='line'><span class="nf">upper</span><span class="p">(</span><span class="s">&quot;llo&quot;</span><span class="p">,</span> <span class="p">[</span><span class="sc">$E</span><span class="p">,</span> <span class="sc">$H</span><span class="p">,</span> <span class="sc">$#</span><span class="p">])</span>
</span><span class='line'><span class="nf">upper</span><span class="p">(</span><span class="s">&quot;lo&quot;</span><span class="p">,</span> <span class="p">[</span><span class="sc">$L</span><span class="p">,</span> <span class="sc">$E</span><span class="p">,</span> <span class="sc">$H</span><span class="p">,</span> <span class="sc">$#</span><span class="p">])</span>
</span><span class='line'><span class="nf">upper</span><span class="p">(</span><span class="s">&quot;o&quot;</span><span class="p">,</span> <span class="p">[</span><span class="sc">$L</span><span class="p">,</span> <span class="sc">$L</span><span class="p">,</span> <span class="sc">$E</span><span class="p">,</span> <span class="sc">$H</span><span class="p">,</span> <span class="sc">$#</span><span class="p">])</span>
</span><span class='line'><span class="nf">upper</span><span class="p">([],</span> <span class="p">[</span><span class="sc">$O</span><span class="p">,</span> <span class="sc">$L</span><span class="p">,</span> <span class="sc">$L</span><span class="p">,</span> <span class="sc">$E</span><span class="p">,</span> <span class="sc">$H</span><span class="p">,</span> <span class="sc">$#</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ul>
<li>最后，<code>upper([], [$O, $L, $L, $E, $H, $#])</code> 匹配 <code>upper([], N), lists:reverse(N)</code></li>
</ul>
</blockquote>

<p>模式匹配让你能够将代码逻辑进行分拆，这使得函数的每个子句变得更小、更具可读性。这就是为什么我们经常可以看到 C 函数动辄超过 100 行代码，而 Erlang 函数通常不会超过 20 行的原因。</p>

<h2>递归魔法</h2>

<p>学习 C 编程的时候，我被告知 <code>递归是有害的</code>，应当尽可能避免使用它。但在函数式编程的世界里，完全就是另外一回事了。</p>

<p>回头看看上文的所有代码，你有看到循环语句吗？没有。递归函数呢？到处都是。在需要迭代或递归的场景里，递归取代了 <code>for/while</code> 循环，代码看起来非常简洁。为什么会是这样呢？回想一下 C 语言的 <code>for</code> 循环，其实包含了状态改变，每次循环里修改迭代器的值，直到它满足了退出的条件，跳出循环。但 Erlang 不允许内部状态的改变，所以她使用递归取代了通常的 <code>for/while</code> 循环。</p>

<p>但是，对此你心有疑虑&hellip;</p>

<h3>递归的性能很差</h3>

<p>这其实是一个 <code>伪命题</code>。</p>

<p>让我举个例子。我们通常认为，通过寄存器传递参数要远比通过堆栈传递快得多，函数调用中，Intel CPU 由于缺少足够的通用寄存器（相比较RISC CPU），因此它非常依赖堆栈的 <code>push/pop</code> 操作。为了提高性能它引入了寄存器栈，这让 <code>push/pop</code> 操作变得和操作寄存器一样快。</p>

<p>让我们看回递归，我们在 C 中很少使用递归，并且根据 <code>80/20</code> 法则（什么意思？），没有必要马上对递归进行优化，对吧？而对 Erlang 而言，递归就是代码的生命，编译器岂敢不对其进行优化！所以说吧，你的直觉是不对的 —— 递归并非天生就是很慢的，在 C 里面它确实慢，但在 Erlang 里，它非常快。</p>

<h3>递归很容易导致堆栈溢出</h3>

<p>这个论断也并不十分准确，如果你以正确的方式编写程序的话。在递归中 Erlang 对堆栈操作做了优化，尤其是尾递归。举例说明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span>
</span></code></pre></td></tr></table></div></figure>


<p>这不是一个尾递归，因为堆栈数据必须保存下来做进一步计算。让我们把它改成尾递归的版本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">fac1</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fac1</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">fac1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">M</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">M</span><span class="p">;</span>
</span><span class='line'><span class="nf">fac1</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">M</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">fac1</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nv">N</span> <span class="o">*</span> <span class="nv">M</span><span class="p">).</span>
</span></code></pre></td></tr></table></div></figure>


<p>每进行一次递归调用，我们都能够安全地把上一次递归调用产生的堆栈数据丢弃，这就是尾递归。尾递归的好处是，你只需要保存少量并且固定大小的内存数据，所以不需要担心长时间运行的递归程序会有堆栈溢出的问题。</p>

<p>在 Erlang 里你可以尽可能地使用尾递归编程。</p>

<h2>函数式编程</h2>

<p>特别关注一下那些可以被递归访问的数据，例如 list（包括string），list 可以做如下处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">retrieve</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="nv">H</span><span class="p">,</span> <span class="nv">T</span><span class="p">}.</span>
</span><span class='line'>
</span><span class='line'><span class="c">%% or even</span>
</span><span class='line'><span class="nf">retrieve1</span><span class="p">([</span><span class="nv">H1</span><span class="p">,</span> <span class="nv">H2</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="nv">H1</span><span class="p">,</span> <span class="nv">H2</span><span class="p">,</span> <span class="nv">T</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>请牢记 map/reduce 的概念。</p>

<p>对于算法问题，想一想如何通过数学公式来实现它，如果落地到了具体的数学公式了，那么这样的问题应该很容易用 Erlang 来编程解决。分而治之，不要被细节问题所迷惑。</p>

<p>我们用 atoi(S) 函数为例，公式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>     <span class="p">|</span>- S<span class="o">[</span>0<span class="o">]</span> is <span class="s1">&#39;-&#39;</span>:  -1 * atoi<span class="o">(</span>S<span class="o">[</span>1:<span class="o">]</span>, 0<span class="o">)</span>
</span><span class='line'>atoi<span class="o">(</span>S<span class="o">)</span> -+
</span><span class='line'>     <span class="p">|</span>- <span class="k">else</span>:         atoi<span class="o">(</span>S, 0<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>          <span class="p">|</span>- S is <span class="o">[]</span>:       Acc
</span><span class='line'>atoi<span class="o">(</span>S, Acc<span class="o">)</span> -+- S<span class="o">[</span>X<span class="o">]</span> is digit: atoi<span class="o">(</span>S<span class="o">[</span>X+1:<span class="o">]</span>, <span class="m">10</span> * Acc + digit<span class="o">(</span>S<span class="o">))</span>
</span><span class='line'>          <span class="p">|</span>- <span class="k">else</span>:          Acc
</span></code></pre></td></tr></table></div></figure>


<p>实现代码例子如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">math</span><span class="p">).</span>
</span><span class='line'><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">atoi</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">atoi</span><span class="p">([</span><span class="sc">$-</span><span class="p">|</span><span class="nv">S</span><span class="p">])</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">atoi</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="nf">atoi</span><span class="p">(</span><span class="nv">S</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">atoi</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">atoi</span><span class="p">([],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Acc</span><span class="p">;</span>
</span><span class='line'><span class="nf">atoi</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="k">when</span> <span class="nv">H</span> <span class="o">&gt;=</span> <span class="sc">$0</span><span class="p">,</span> <span class="nv">H</span> <span class="o">=&lt;</span> <span class="sc">$9</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">atoi</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">Acc</span> <span class="o">+</span> <span class="p">(</span><span class="nv">H</span> <span class="o">-</span> <span class="sc">$0</span><span class="p">));</span>
</span><span class='line'><span class="nf">atoi</span><span class="p">(_</span><span class="nv">S</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Acc</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>比较一下 atoi() 函数的 C 实现，Erlang 的实现版本更直观反映了其算法逻辑，你几乎能一次就编写出正确的代码。</p>

<h2>拥抱进程</h2>

<p>进程使用起来并不难，它以一种结构相对松散的、异步的方式组织起你的系统。你只需要去习惯它，将它当作一个 worker，一个 object，或者其他类似的东西。</p>

<h2>让它出错吧</h2>

<p>C 程序员通常需要在编程时考虑覆盖尽可能多的参数值条件，而 Erlang 程序员则不需要如此，看这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">%% good code</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nb">is_integer</span><span class="p">(</span><span class="nv">N</span><span class="p">),</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Acc</span><span class="p">;</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fac</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Acc</span> <span class="o">*</span> <span class="nv">N</span><span class="p">).</span>
</span><span class='line'>
</span><span class='line'><span class="c">%% bad code</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nb">is_integer</span><span class="p">(</span><span class="nv">N</span><span class="p">),</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span>                           <span class="o">-&gt;</span> <span class="p">{</span><span class="n">error</span><span class="p">,</span> <span class="s">&quot;argument must be positive integer&quot;</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Acc</span><span class="p">;</span>
</span><span class='line'><span class="nf">fac</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fac</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Acc</span> <span class="o">*</span> <span class="nv">N</span><span class="p">).</span>
</span></code></pre></td></tr></table></div></figure>


<p>用非法参数调用第一段代码将会导致异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>1&gt; c<span class="o">(</span>math<span class="o">)</span>.
</span><span class='line'><span class="o">{</span>ok,math<span class="o">}</span>
</span><span class='line'>2&gt; math:fac<span class="o">(</span>10<span class="o">)</span>.
</span><span class='line'>3628800
</span><span class='line'>3&gt; math:fac<span class="o">(</span>-10<span class="o">)</span>.
</span><span class='line'>** exception error: no <span class="k">function</span> clause matching math:fac<span class="o">(</span>-10<span class="o">)</span> <span class="o">(</span>math.erl, line 14<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要为负数的情况编写代码吗？C 程序需要，Erlang 不需要！用负数调用时，第二段代码使得程序得以继续运行，但是给调用者增加了不必要的处理，调用者需要为此添加额外的代码，给程序徒增复杂性。还是直接让进程退出吧，我们只在真正需要异常处理的场景里为此操心就行了。</p>

<hr />

<h1>Erlang 学习资料</h1>

<p>恭喜你！读完了这篇文章，你将可以开始学习驯服属于你的那只 Toruk了，下面是对你很有帮助的一些 <code>武器</code>：</p>

<blockquote><ul>
<li><strong>Joe Armstrong</strong> 的经典之作 《 <strong>Programming Erlang - software for a concurrent world</strong> 》。学习一门语言最好的途径是阅读该门语言作者的作品，我力荐你好好读一读这本书，尤其是里面有关 <code>顺序编程</code>、<code>并发编程</code> 和 <code>OTP</code> 的章节。</li>
<li><a href="http://www.erlang.org/doc/">Erlang doc</a>。有任何疑问时作为参考。</li>
<li>用 Erlang 编程解决你日常工作中遇到的问题，以下例子可供参考：

<ul>
<li>给定一个文件，计算经典的 wordcount</li>
<li>实现 cloc (给定一个目录，计算不同语言的代码行数)</li>
<li>编写一个消息服务器，将 topN 未读消息保存在内存，其余的保存在 mnesia 中</li>
<li>编写一个 markdown 格式解析器</li>
<li>基于 mochiweb 编写一个 web 框架</li>
<li>编写一个 L3/L4 防火墙软件用于处理 handles symmetric NAT translation (to focus on the problem itself you should use the data from tcpdump).</li>
</ul>
</li>
<li>阅读开源项目代码，例如 ranch, cowboy, boss_db, 等等。</li>
</ul>
</blockquote>

<p>Hope you have fun!</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解C/C++中的#和##操作符]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/09/15/understanding-number-and-number-number-in-c-slash-c-plus-plus/"/>
    <updated>2014-09-15T00:09:19+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/09/15/understanding-number-and-number-number-in-c-slash-c-plus-plus</id>
    <content type="html"><![CDATA[<p>这两个符号在 C/C++ 语言中属于<code>编译器预处理</code>的范畴，属于编译期概念（而非运行期概念）</p>

<p><strong><code>##</code>连接符</strong> 的功能是在带参数的宏定义中将两个子串(token)连接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串</p>

<p><code>所谓的子串就是指编译器能够识别的最小语法单元。具体的定义在编译原理里面有详尽解释，但不知道也无所谓</code></p>

<p><strong><code>#</code>连接符</strong> 的功能是把传递过来的参数当成字符串进行替代，即所谓 <code>字符串化</code></p>

<!-- more -->


<h2>实例说明</h2>

<p>假设程序中已经定义了这样一个带参数的宏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define paster(n) printf(&quot;token&quot; #n &quot; = %d&quot;, token##n)</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时又定义了一个整型变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">token9</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在在主程序中以下面的方式调用这个宏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">paster</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么在编译时，上面的这句话被扩展为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;token&quot;</span> <span class="s">&quot;9&quot;</span> <span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">token9</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果自然就是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ token9</span> <span class="o">=</span> 9
</span></code></pre></td></tr></table></div></figure>


<h2>小记</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">## -- 连接两个参数</span>
</span><span class='line'><span class="c">#  -- 字符串化</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Objective-C中缀符]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/09/12/understanding-infix-notation-in-oc/"/>
    <updated>2014-09-12T17:19:20+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/09/12/understanding-infix-notation-in-oc</id>
    <content type="html"><![CDATA[<p>初学 Objective-C ，对其方法的声明语法感到很奇怪。比如：</p>

<p>声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">@</span><span class="n">interface</span> <span class="nl">C</span> <span class="p">:</span> <span class="n">NSObject</span>
</span><span class='line'><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nl">fun</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">a</span> <span class="nl">second</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">@</span><span class="n">implementation</span> <span class="n">C</span>
</span><span class='line'><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nl">fun</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">a</span> <span class="nl">second</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">b</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span> <span class="nl">fun</span><span class="p">:</span> <span class="mi">2</span> <span class="nl">second</span><span class="p">:</span> <span class="mi">3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>书上说这种语法称为中缀符的形式，我的疑问是：</p>

<blockquote><ul>
<li><code>fun</code> 应该就是方法名吧？那 <code>second</code> 理解为什么？</li>
<li>如果 <code>second</code> 理解为第二个参数的名字，那 <code>b</code> 又是什么？同时 <code>fun</code> 又是什么？</li>
</ul>
</blockquote>

<!-- more -->


<p>好吧我的问题也许有些奇怪，对于一个习惯了 C/C++ 等“正常”语法的人来说，一时没转过弯来。一番 <code>gb</code> 之后，参考了多人的说法，算是基本理解了 OC 的方法参数名。</p>

<p>整理如下：</p>

<blockquote><ul>
<li><strong>方法修饰符</strong></li>
</ul>
</blockquote>

<ol>
<li><code>-</code> 代表此方法是<code>实例方法</code>，必须先生成类实例，通过实例才能调用该方法</li>
<li><code>+</code> 代表此方法是类的<code>静态方法</code>，可以直接调用，而不用生成类实例</li>
</ol>


<blockquote><ul>
<li><strong>参数类型</strong></li>
</ul>
</blockquote>

<p>  a 与 b 分别是两个参数，均为 int 类型</p>

<blockquote><ul>
<li><strong>方法签名</strong></li>
</ul>
</blockquote>

<p>  本例中，fun 和 second 组成了该方法的签名关键字。不过还是有些怪异，这样理解吧，第一个参数是没有参数名的，<strong>如果硬要说有，那就是方法名</strong>，统一说来，见到冒号，冒号前面那个就是参数名</p>

<p>再举例，也可以编写没有参数名的方法定义与调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nl">fun</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nl">a</span><span class="p">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span> <span class="nl">fun</span><span class="p">:</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何编写一个Hive Generic UDF]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/09/05/writing-a-hive-generic-udf/"/>
    <updated>2014-09-05T05:40:22+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/09/05/writing-a-hive-generic-udf</id>
    <content type="html"><![CDATA[<h2>业务背景</h2>

<p>公司的数据分析业务 ETL 过程中，原始数据经过数据清洗之后，统一转换成自定义的 protobuf <code>CustomEventMessage</code> 格式，用户自定义事件 ( 多个KV对的格式 ) 保存在 <code>event_args</code> 字段中。最终 <code>CustomEventMessage</code> 数据将导入 <code>hive</code> 中，在没有 <code>Protobuf Serde</code> 之前，这需要先将数据重新转换为文本格式。
最后，在 <code>hive</code> 的建表语句中 <code>event_args</code> 字段声明为 <code>MAP</code> 类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">event_args</span> <span class="k">MAP</span><span class="o">&lt;</span><span class="nb">INT</span><span class="p">,</span> <span class="nb">INT</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">or</span>
</span><span class='line'><span class="n">event_args</span> <span class="k">MAP</span><span class="o">&lt;</span><span class="n">STRING</span><span class="p">,</span> <span class="n">STRING</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>举例来说，某个 <code>event_args</code> 字段带有两个自定义参数 <code>money</code> 和 <code>paytype</code>，转换后的文本内容为：（ Key 1 和 3 是预定的 ）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="mi">1</span><span class="p">:</span><span class="mi">200</span><span class="o">|</span><span class="mi">3</span><span class="p">:</span><span class="mi">1</span>
</span><span class='line'><span class="k">or</span>
</span><span class='line'><span class="n">money</span><span class="p">:</span><span class="mi">200</span><span class="o">|</span><span class="n">paytype</span><span class="p">:</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>在后续 hive 查询脚本中引用该字段提取其中特定的事件（ 比如支付类型 <code>paytype</code> ）很简单且直观：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">event_args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">or</span>
</span><span class='line'><span class="n">event_args</span><span class="p">[</span><span class="s1">&#39;paytype&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h3>存在的问题及对策</h3>

<p>多了转文本这一步骤，维护起来太繁琐，因此开发了 <strong>ProtobufSerde</strong> ，让 <code>hive</code> 能直接支持存取 <code>protobuf</code> 格式的数据，这样 <code>CustomEventMessage</code> 入库 hive 将会方便很多。</p>

<p>当然，现在的 hive 程序也需要做一些相应的调整，比如上述 <code>event_args</code> 字段的读取就麻烦得多了。现在的建表语句变成如下形式（直接对应 proto）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="n">event_args</span> <span class="nb">ARRAY</span><span class="o">&lt;</span> <span class="n">STRUCT</span><span class="o">&lt;</span><span class="n">key_int</span><span class="p">:</span><span class="nb">BIGINT</span><span class="p">,</span><span class="n">key_str</span><span class="p">:</span><span class="n">STRING</span><span class="p">,</span><span class="n">value_int</span><span class="p">:</span><span class="nb">BIGINT</span><span class="p">,</span><span class="n">value_str</span><span class="p">:</span><span class="n">STRING</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>select</code> 得到的数据格式将是类似这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="p">[</span><span class="err">{</span><span class="ss">&quot;key_int&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="ss">&quot;key_str&quot;</span><span class="p">:</span><span class="ss">&quot;money&quot;</span><span class="p">,</span><span class="ss">&quot;value_int&quot;</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span><span class="ss">&quot;value_str&quot;</span><span class="p">:</span><span class="ss">&quot;200&quot;</span><span class="err">}</span><span class="p">,</span><span class="err">{</span><span class="ss">&quot;key_int&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="ss">&quot;key_str&quot;</span><span class="p">:</span><span class="ss">&quot;paytype&quot;</span><span class="p">,</span><span class="ss">&quot;value_int&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="ss">&quot;value_str&quot;</span><span class="p">:</span><span class="ss">&quot;1&quot;</span><span class="err">}</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里例子中，为了得到 <code>paytype</code>，我们可以在查询语句中这样书写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="n">event_args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value_int</span> <span class="k">FROM</span> <span class="n">s_CustomEventMessage</span> <span class="k">WHERE</span> <span class="n">pyearmonth</span><span class="o">=</span><span class="s1">&#39;201403&#39;</span> <span class="k">and</span> <span class="n">pday</span><span class="o">=</span><span class="s1">&#39;07&#39;</span> <span class="k">and</span> <span class="n">event_id</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>引入的新问题</h3>

<p>看起来依旧方便的这种写法，基于 <code>2</code> 个前提：</p>

<blockquote><ul>
<li><code>event_args</code> 中有 <code>paytype</code> 事件</li>
<li><code>paytype</code> 自定义事件在 <code>event_args</code> 中是第 <code>2</code> 个 item（ index 1 ）</li>
</ul>
</blockquote>

<p>遗憾的是，这两个条件都没有办法满足。因此现在需要通过 遍历整个 <code>event_args</code> 的内容，找出我们所关心的事件。
OK，很明显，我们需要 <code>UDF</code> 来完成这一任务。</p>

<hr />

<h2>如何编写 Hive GenericUDF</h2>

<p>为编写 UDF，Hive 中提供了两套不同的接口，分别是：</p>

<blockquote><ul>
<li>Simple API - <code>org.apache.hadoop.hive.ql.exec.UDF</code></li>
<li>Complex API - <code>org.apache.hadoop.hive.ql.udf.generic.GenericUDF</code></li>
</ul>
</blockquote>

<p><code>UDF</code> 接口非常容易编写，但其局限性在于它只适用于函数输入参数和返回值都是 <code>Java原生类型</code> 的场景，这里我们的输入参数类型是 <code>ARRAY&lt; STRUCT&lt;key_int:BIGINT,key_str:STRING,value_int:BIGINT,value_str:STRING&gt; &gt;</code>，返回值是 <code>BIGINT</code> 或者 <code>STRING</code> 类型，因此 <code>UDF</code> 接口满足不了需求。</p>

<p>GenericUDF 是 Hive UDFs 中的 <strong>瑞士军刀</strong>，适用处理 Hive 的复杂类型如 <code>MAP</code>、<code>ARRAY</code>、<code>STRUCT</code> 以及在此之上的各种嵌套类型。下面我们就使用它来完成这一任务。</p>

<h3>几点准备知识：</h3>

<blockquote><ul>
<li>UDF 函数通过 <code>ObjectInspector</code> 来访问传入的参数，因此 <code>ObjectInspector</code> 的概念很重要
（对于 ObjectInspector 不太懂，等了解学习以后单独写个文档介绍）</li>
<li>GenericUDFs 中使用的很多函数，特别是 <code>ObjectInspector</code> 的众多子类函数，返回 <code>Object</code> 类型，这意味着：
（1） 编译器无法帮助我们做类型检查
（2） 很多时候我们不知道拿到手的对象的实际类型（hadoop 的 tasklogs 是很有用的工具，可以借助它来调试）</li>
</ul>
</blockquote>

<p>所有的自定义 <code>GenericUDFs</code> 继承自 <code>GenericUDF</code> 类，因此需要实现以下三个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">ObjectInspector</span> <span class="nf">initialize</span><span class="o">(</span><span class="n">ObjectInspector</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">DeferredObject</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="n">String</span> <span class="nf">getDisplayString</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">children</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1） initialize()函数</h3>

<p>initialize() 函数在 UDF 第一次调用时执行，主要完成四件事：</p>

<blockquote><ul>
<li>检查输入参数类型（在我们的例子中，即 <code>array&lt;struct&lt;key_int:bigint,key_str:string,value_int:bigint,value_str:string&gt;&gt;</code> 和 <code>string</code>）</li>
<li>设置并返回一个跟函数返回值匹配的 <code>ObjectInspector</code> 对象</li>
<li>把输入参数中用到的各种 <code>ObjectInspectors</code> 保存到全局变量中</li>
<li>设置返回值</li>
</ul>
</blockquote>

<h3>2）evaluate() 函数</h3>

<p>evaluate() 函数接收输入实参，完成计算后返回结果。如前所述，我们通过各种 <code>ObjectInspectors</code> 来访问传入的参数，<code>ObjectInspectors</code> 是由我们在 initialize() 函数中保存起来的。我们需要知道：</p>

<blockquote><ul>
<li>array&lt;> 在 Java 中用 ArrayList&lt;> 来表示</li>
<li>struct&lt;> 在 Java 中用 Object[] 来表示</li>
<li>使用 hadoop 的 Writable 和 Text 类而非 Java 原生类型</li>
</ul>
</blockquote>

<h3>3） getDisplayString() 函数</h3>

<p>不那么重要，我们只需返回一个字符串，表示该 UDF 是干什么的就行了，在我们使用 <code>EXPLAIN</code> 调试 <code>hql</code> 语句时，该信息会被输出。</p>

<hr />

<h2>代码实现</h2>

<p>代码中已经有了详尽的注释来解释每一个步骤，可以参考着上面的内容来理解。不再详述。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">mjyun</span><span class="o">.</span><span class="na">hive</span><span class="o">.</span><span class="na">udf</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.io.Text</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.io.LongWritable</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.io.IntWritable</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.ql.exec.UDFArgumentException</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.ql.metadata.HiveException</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.ql.udf.generic.GenericUDF</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.ListObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.StandardListObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.StructField</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.primitive.StringObjectInspector</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.objectinspector.primitive.LongObjectInspector</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.lazy.LazyString</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.apache.hadoop.hive.serde2.lazy.LazyLong</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UDFGetValueFromEventArgsStr</span> <span class="kd">extends</span> <span class="n">GenericUDF</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Global variables that inspect the input.</span>
</span><span class='line'>    <span class="c1">// These are set up during the initialize() call, and are then used during the calls to evaluate()</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ListObjectInspector</span>   <span class="n">listOI</span><span class="o">;</span>                   <span class="c1">// ObjectInspector for the list (array&lt;&gt;)</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">StructObjectInspector</span> <span class="n">structOI</span><span class="o">;</span>                 <span class="c1">// ObjectInspector for the struct&lt;&gt;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ObjectInspector</span>       <span class="n">kiOI</span><span class="o">,</span> <span class="n">ksOI</span><span class="o">,</span> <span class="n">viOI</span><span class="o">,</span> <span class="n">vsOI</span><span class="o">;</span>   <span class="c1">// ObjectInspector for the elements of the struct&lt;&gt;: key_int, key_str, value_int, value_str</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">StringObjectInspector</span> <span class="n">targetOI</span><span class="o">;</span>                 <span class="c1">// ObjectInspector for the second arg that we match with target field</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getDisplayString</span> <span class="o">(</span> <span class="n">String</span> <span class="o">[]</span><span class="n">arg0</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;getValueFromEventArgsStr&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// this is like the evaluate method of the simple API. </span>
</span><span class='line'>    <span class="c1">// It takes the actual arguments and returns the result.</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">ObjectInspector</span> <span class="nf">initialize</span> <span class="o">(</span> <span class="n">ObjectInspector</span><span class="o">[]</span> <span class="n">arguments</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">UDFArgumentException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">arguments</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;getValueFromEventArgsStr only takes 2 arguments: List&lt;Struct&lt;bigint,string,bigint,string&gt;&gt;, String&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 1. Check we received the right object types.</span>
</span><span class='line'>        <span class="n">ObjectInspector</span> <span class="n">a</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>        <span class="n">ObjectInspector</span> <span class="n">b</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">!(</span> <span class="n">a</span> <span class="k">instanceof</span> <span class="n">ListObjectInspector</span> <span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;The first argument must be a Array&lt;Struct&gt;, &quot;</span>
</span><span class='line'>                    <span class="o">+</span> <span class="s">&quot; but &quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">!(</span> <span class="n">b</span> <span class="k">instanceof</span> <span class="n">StringObjectInspector</span> <span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;The second argument must be a String, &quot;</span>
</span><span class='line'>                    <span class="o">+</span> <span class="s">&quot; but &quot;</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 2. Get the object inspector for the list(array) elements; this should be a StructObjectInspector</span>
</span><span class='line'>        <span class="c1">// Then check that the struct has the correct fields.</span>
</span><span class='line'>        <span class="c1">// Also, store the ObjectInspectors for use later in the evaluate() method</span>
</span><span class='line'>        <span class="n">listOI</span>   <span class="o">=</span> <span class="o">(</span><span class="n">ListObjectInspector</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>
</span><span class='line'>        <span class="n">targetOI</span> <span class="o">=</span> <span class="o">(</span><span class="n">StringObjectInspector</span><span class="o">)</span><span class="n">b</span><span class="o">;</span>
</span><span class='line'>        <span class="n">structOI</span> <span class="o">=</span> <span class="o">(</span><span class="n">StructObjectInspector</span><span class="o">)</span><span class="n">listOI</span><span class="o">.</span><span class="na">getListElementObjectInspector</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getAllStructFieldRefs</span><span class="o">().</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Incorrect number of fields in the struct. &quot;</span>
</span><span class='line'>                    <span class="o">+</span> <span class="s">&quot;The first argument of type Array&lt;Struct&gt; must contains 4 fields, &quot;</span>
</span><span class='line'>                    <span class="o">+</span> <span class="s">&quot; but &quot;</span> <span class="o">+</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getAllStructFieldRefs</span><span class="o">().</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; fields is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">StructField</span> <span class="n">key_int</span>   <span class="o">=</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;key_int&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">StructField</span> <span class="n">key_str</span>   <span class="o">=</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;key_str&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">StructField</span> <span class="n">value_int</span> <span class="o">=</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;value_int&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">StructField</span> <span class="n">value_str</span> <span class="o">=</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;value_str&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">key_int</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;No \&quot;key_int\&quot; field in input structure &quot;</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">key_str</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;No \&quot;key_str\&quot; field in input structure &quot;</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">value_int</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;No \&quot;value_int\&quot; field in input structure &quot;</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">value_str</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;No \&quot;value_str\&quot; field in input structure &quot;</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">kiOI</span> <span class="o">=</span> <span class="n">key_int</span><span class="o">.</span><span class="na">getFieldObjectInspector</span><span class="o">();</span>
</span><span class='line'>        <span class="n">ksOI</span> <span class="o">=</span> <span class="n">key_str</span><span class="o">.</span><span class="na">getFieldObjectInspector</span><span class="o">();</span>
</span><span class='line'>        <span class="n">viOI</span> <span class="o">=</span> <span class="n">value_int</span><span class="o">.</span><span class="na">getFieldObjectInspector</span><span class="o">();</span>
</span><span class='line'>        <span class="n">vsOI</span> <span class="o">=</span> <span class="n">value_str</span><span class="o">.</span><span class="na">getFieldObjectInspector</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">kiOI</span><span class="o">.</span><span class="na">getCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">ObjectInspector</span><span class="o">.</span><span class="na">Category</span><span class="o">.</span><span class="na">PRIMITIVE</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input primitive? key_int field must be a bigint, but &quot;</span> <span class="o">+</span> <span class="n">kiOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">ksOI</span><span class="o">.</span><span class="na">getCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">ObjectInspector</span><span class="o">.</span><span class="na">Category</span><span class="o">.</span><span class="na">PRIMITIVE</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input primitive? key_str field must be a string, but &quot;</span> <span class="o">+</span> <span class="n">ksOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">viOI</span><span class="o">.</span><span class="na">getCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">ObjectInspector</span><span class="o">.</span><span class="na">Category</span><span class="o">.</span><span class="na">PRIMITIVE</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input primitive? value_int field must be a bigint, but &quot;</span> <span class="o">+</span> <span class="n">viOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">vsOI</span><span class="o">.</span><span class="na">getCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">ObjectInspector</span><span class="o">.</span><span class="na">Category</span><span class="o">.</span><span class="na">PRIMITIVE</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input primitive? value_str field must be a string, but &quot;</span> <span class="o">+</span> <span class="n">vsOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">((</span><span class="n">PrimitiveObjectInspector</span><span class="o">)</span><span class="n">kiOI</span><span class="o">).</span><span class="na">getPrimitiveCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">PrimitiveObjectInspector</span><span class="o">.</span><span class="na">PrimitiveCategory</span><span class="o">.</span><span class="na">LONG</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input correct primitive? key_int field must be a bigint, but &quot;</span> <span class="o">+</span> <span class="n">kiOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">((</span><span class="n">PrimitiveObjectInspector</span><span class="o">)</span><span class="n">ksOI</span><span class="o">).</span><span class="na">getPrimitiveCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">PrimitiveObjectInspector</span><span class="o">.</span><span class="na">PrimitiveCategory</span><span class="o">.</span><span class="na">STRING</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input correct primitive? key_str field must be a string, but &quot;</span> <span class="o">+</span> <span class="n">ksOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">((</span><span class="n">PrimitiveObjectInspector</span><span class="o">)</span><span class="n">viOI</span><span class="o">).</span><span class="na">getPrimitiveCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">PrimitiveObjectInspector</span><span class="o">.</span><span class="na">PrimitiveCategory</span><span class="o">.</span><span class="na">LONG</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input correct primitive? value_int field must be a bigint, but &quot;</span> <span class="o">+</span> <span class="n">viOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">((</span><span class="n">PrimitiveObjectInspector</span><span class="o">)</span><span class="n">vsOI</span><span class="o">).</span><span class="na">getPrimitiveCategory</span><span class="o">()</span> <span class="o">!=</span> <span class="n">PrimitiveObjectInspector</span><span class="o">.</span><span class="na">PrimitiveCategory</span><span class="o">.</span><span class="na">STRING</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UDFArgumentTypeException</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Is input correct primitive? value_str field must be a bigint, but &quot;</span> <span class="o">+</span> <span class="n">vsOI</span><span class="o">.</span><span class="na">getTypeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is found&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 3. the return type of our function is a bigint, so we provide the correct object inspector</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">PrimitiveObjectInspectorFactory</span><span class="o">.</span><span class="na">javaLongObjectInspector</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The evaluate() method. The input is passed in as an array of DeferredObjects, so that</span>
</span><span class='line'>    <span class="c1">// computation is not wasted on deserializing them if they&#39;re not actually used</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">evaluate</span><span class="o">(</span> <span class="n">DeferredObject</span><span class="o">[]</span> <span class="n">arguments</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">HiveException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Should take 2 arguments</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="n">arguments</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">()</span> <span class="o">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Iterate over the elements of the input array</span>
</span><span class='line'>        <span class="c1">// If a key_str of arguments[1] if found, return key_int</span>
</span><span class='line'>        <span class="c1">// Else return null</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">nelements</span> <span class="o">=</span> <span class="n">listOI</span><span class="o">.</span><span class="na">getListLength</span><span class="o">(</span><span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">()),</span> <span class="n">val_int</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nelements</span><span class="o">;</span> <span class="n">i</span><span class="o">++</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Text</span> <span class="n">tt</span> <span class="o">=</span> <span class="o">(</span><span class="n">Text</span><span class="o">)(</span><span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldData</span><span class="o">(</span> <span class="n">listOI</span><span class="o">.</span><span class="na">getListElement</span><span class="o">(</span><span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(),</span> <span class="n">i</span><span class="o">),</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;key_str&quot;</span><span class="o">)</span> <span class="o">));</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>            <span class="c1">// String skey_str = targetOI.getPrimitiveJavaObject(LSkey_str);</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">target</span> <span class="o">=</span> <span class="n">targetOI</span><span class="o">.</span><span class="na">getPrimitiveJavaObject</span><span class="o">(</span><span class="n">arguments</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">get</span><span class="o">());</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span> <span class="n">t</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Long</span> <span class="n">ll</span> <span class="o">=</span> <span class="o">((</span><span class="n">LongWritable</span><span class="o">)(</span><span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldData</span><span class="o">(</span> <span class="n">listOI</span><span class="o">.</span><span class="na">getListElement</span><span class="o">(</span><span class="n">arguments</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(),</span> <span class="n">i</span><span class="o">),</span> <span class="n">structOI</span><span class="o">.</span><span class="na">getStructFieldRef</span><span class="o">(</span><span class="s">&quot;value_int&quot;</span><span class="o">)</span> <span class="o">))).</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">ll</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>小结</h2>

<p>本文粗浅地介绍了一个处理 <code>hive</code> <code>array&lt;struct&lt;&gt;&gt;</code> 数据类型的 <code>GenericUDF</code> 应该如何编写，大概就是这些了，第一次接触，略作记录，仅供参考。</p>

<hr />

<h2>参考</h2>

<ol>
<li><a href="http://hive.apache.org/javadocs/r0.10.0/api/org/apache/hadoop/hive/ql/udf/generic/GenericUDF.html">官方GenericUDF API</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins">HivePlugins</a></li>
<li><a href="https://www.inkling.com/read/hadoop-definitive-guide-tom-white-3rd/chapter-12/ch12-section-08">User-Defined Functions</a></li>
<li><a href="http://www.congiu.com/structured-data-in-hive-a-generic-udf-to-sort-arrays-of-structs/">Structured data in Hive: a generic UDF to sort arrays of structs</a></li>
<li><a href="http://blog.matthewrathbone.com/2013/08/10/guide-to-writing-hive-udfs.html">Hadoop Hive UDF Tutorial - Extending Hive with Custom Functions</a></li>
<li><a href="http://www.baynote.com/2012/11/a-word-from-the-engineers/">Writing a Hive Generic UDF</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Octopress]]></title>
    <link href="http://RonnieTsang.github.io/blog/2014/09/05/hello-octopress/"/>
    <updated>2014-09-05T01:35:36+08:00</updated>
    <id>http://RonnieTsang.github.io/blog/2014/09/05/hello-octopress</id>
    <content type="html"><![CDATA[<p>想要有自己的博客这个想法很久很久了&hellip;行动上却很诚实，鄙视一下自己！</p>

<hr />

<p><code>2013-10-31</code> 号申请的域名 <a href="http://lseek.me">lseek.me</a> 一直闲置到现在，着实是暴殄天物！想当初好不容易才找到这个为数甚少的未被注册的 C 标准库函数名 <code>lseek</code>， 而且 <code>lseek.me</code> 刚好带有点 <code>寻求自我</code> 的意味，那时还真有点小激动呢～～～导致手一抖 280 块大洋没了 >_&lt;</p>

<p>前段时间无意知道 <code>github</code> + <code>octopress</code> 搭建 blog 这玩意，而且还是免费的，<code>github</code> 为你管理服务器，并提供无限流量，世界各地都有理想的访问速度，这还得了，叼炸天啊，不过过瘾怎么行！</p>

<p>于是一通搜索，看了诸多教程，基本上都是大同小异，照虎画猫很快把 blog 搭建了起来。本文简单记录一下整个过程：</p>

<!-- more -->


<hr />

<h2><strong>准备工作</strong></h2>

<blockquote><ul>
<li>安装 <a href="http://git-scm.com/">Git</a></li>
<li>安装 Ruby 1.9.3 或 更高版本 ( 通过 <a href="http://octopress.org/docs/setup/rbenv">rbenv</a> 或 <a href="http://octopress.org/docs/setup/rvm">RVM</a> )</li>
</ul>
</blockquote>

<h2><strong>搭建 Octopress 环境</strong></h2>

<h3>1) 安装 Octopress</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'><span class="nv">$ </span><span class="nb">cd </span>octopress
</span></code></pre></td></tr></table></div></figure>


<h3>2) 安装相关依赖</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>gem install bundler
</span><span class='line'><span class="nv">$ </span>rbenv rehash
</span><span class='line'><span class="nv">$ </span>bundle install
</span></code></pre></td></tr></table></div></figure>


<h3>3) 安装默认的 Octopress 主题</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake install
</span></code></pre></td></tr></table></div></figure>


<p>参考：<a href="http://octopress.org/docs/setup/">Initial Setup</a></p>

<h2><strong>配置 Octopress</strong></h2>

<p>Octopress 的作者已经尽量让配置简化了。大多数情况下只需要配置 <code>_config.yml</code> 和 <code>Rakefile</code> 文件即可。其中 <code>Rakefile</code> 是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了 <code>rsync</code>。</p>

<p>这一块我就修改了一下 <code>_config.yml</code> 文件，把 <code>url</code> 和 <code>author</code> 加进去而已。其中 <code>url</code> 是必填项，内容是我在 github 上创建的一个仓库地址 <code>http://ronnietsang.github.io</code></p>

<p>接着删除了里面的 twitter 相关的信息，否则据说是由于 GFW 的原因，将会造成页面加载很慢。</p>

<p>然后修改定制文件 <code>./.themes/classic/source/_includes/custom/head.html</code> 把 google 的自定义字体去掉，原因同上。</p>

<p>参考：<a href="http://octopress.org/docs/configuring/">Basic Configuration</a></p>

<h2><strong>创建第一篇博客</strong></h2>

<p>没错，现在就已经可以开始写博客了！</p>

<h3>1) 创建博文</h3>

<p>Octopress 为我们提供了一些 task 来创建博文和页面。博文必须存储在 <code>source/_posts</code> 目录下，并且需要按照 Jekyll 的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做 <code>url</code> 的一部分，而其中的日期用于对博文的区分和排序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake new_post<span class="o">[</span><span class="s2">&quot;Hello Octopress&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>Hello Octopress</code> 为博文的文件名，创建出来的文件默认是 <code>markdown</code> 格式。上面的命令会创建出这样一个文件：<code>./source/_posts/2014-09-04-hello-octopress.markdown</code>。打开这个文件，可以看到里面有如下一些内容了 ( 告诉Jekyll博客引擎如何处理博文和页面 )：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>---
</span><span class='line'>layout: post
</span><span class='line'>title: <span class="s2">&quot;Hello Octopress&quot;</span>
</span><span class='line'>date: 2014-09-04 19:13:48 +0800
</span><span class='line'>comments: <span class="nb">true</span>
</span><span class='line'>categories:
</span><span class='line'>---
</span></code></pre></td></tr></table></div></figure>


<h3>2) 编辑博文</h3>

<p>接下来使用你喜欢的 markdown 编辑器编写博文，完成后贴到上面的文件中就可以了。</p>

<blockquote><p>我用的是 <code>作业部落</code> 出品的 <a href="https://zybuluo.com/mdeditor">Cmd Markdown</a> 在线编辑阅读器，基本上兼容 github 的 markdown 文法，挺好用的，推荐！</p></blockquote>

<h3>3) 本地预览</h3>

<p>执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake preview
</span></code></pre></td></tr></table></div></figure>


<p>然后就能在浏览器中进行本地预览访问了： <code>http://127.0.0.1:4000/</code> 或 <code>http://localhost:4000/</code>，效果跟仓库中的一样。</p>

<h3>4) 完整过程</h3>

<p>下面是创建并部署博文的一个完整过程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake new_post<span class="o">[</span><span class="s2">&quot;Hello Octopress&quot;</span><span class="o">]</span>
</span><span class='line'><span class="nv">$ </span>rake generate
</span><span class='line'><span class="nv">$ </span>git add .
</span><span class='line'><span class="nv">$ </span>git commit -m <span class="s1">&#39;My first blog -- Hello Octopress&#39;</span>
</span><span class='line'><span class="nv">$ </span>git push origin <span class="nb">source</span>
</span><span class='line'><span class="nv">$ </span>rake deploy
</span></code></pre></td></tr></table></div></figure>


<p>先 mark ，现在还无法部署博文，要等后面部署博客完毕再参考这个过程来部署博文。</p>

<p>参考：<a href="http://octopress.org/docs/blogging">Blogging Basics</a></p>

<hr />

<h2><strong>部署到 Github Pages</strong></h2>

<p>官方推荐了3种部署方式：</p>

<blockquote><ul>
<li><code>GitHub Pages</code>： 部署允许自定义域名，免费，好处是多人开发更方面，坏处是文件随时可以被任何人拉下来</li>
<li><code>Heroku</code>：部署允许自定义域名，免费，并且是私有的</li>
<li><code>Rsync</code>：建议用来部署有自己服务器的个人博客</li>
</ul>
</blockquote>

<p>当然了，我选择的是 <strong><a href="https://pages.github.com/">GitHub Pages</a></strong> 。</p>

<h3>1) 创建仓库</h3>

<p>在 <a href="https://github.com/">GitHub</a> 上创建仓库 <a href="https://github.com/RonnieTsang/ronnietsang.github.io">ronnietsang.github.io</a> ( 网上很多年代久远的教程都是说 com 后缀，现在改成 io 了 )</p>

<blockquote><ul>
<li>保持新建仓库为空的，不要勾选创建 <code>README</code> 文件等选项( 这可能导致后面部署 <code>rake deploy</code> 失败，引出一系列问题 )</li>
<li>一般来说，我们希望在将博客的源码放到 <code>source</code> 分支下，并把生成的内容提交到 <code>master</code> 分支</li>
</ul>
</blockquote>

<h3>2) 配置仓库</h3>

<p>一键配置：只需要利用 octopress 的一个配置 <code>rake</code> 任务就可以自动配置上面创建的仓库，超级方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake setup_github_pages
</span></code></pre></td></tr></table></div></figure>


<p>这个命令会要求你输入刚刚创建的仓库的 <code>url</code> ( <code>ssh</code> or <code>https</code> url )，拷贝过来，回车，接下来它就干了这么几件事：</p>

<blockquote><ul>
<li>将指向远程分支 imathis/octopress 的指针 origin 改名为 octopress</li>
<li>添加刚才创建的仓库为默认的远程分支</li>
<li>将活跃分支从 master 转到 source</li>
<li>根据 github仓库 配置博客的 url</li>
<li>创建一个_deploy目录，用来存放部署到 master 分支的内容</li>
</ul>
</blockquote>

<h3>3) 部署仓库</h3>

<p>命令如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>rake generate
</span><span class='line'><span class="nv">$ </span>rake deploy
</span></code></pre></td></tr></table></div></figure>


<p>干了这么几件事：</p>

<blockquote><ul>
<li>生成博客文件，并拷贝至 _deploy 目录下</li>
<li>将这些内容添加到 git 中，并 commit 和 push 到仓库的 master 分支</li>
</ul>
</blockquote>

<p>不过博客的 <code>source</code> 需要单独提交，执行如下命令就可以将 <code>source</code> 提交到仓库的 <code>source</code> 分支下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>git add .
</span><span class='line'><span class="nv">$ </span>git commit -m <span class="s1">&#39;Initial source commit&#39;</span>
</span><span class='line'><span class="nv">$ </span>git push origin <span class="nb">source</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，博客已经完成基本的部署。但是当我满心期待地使用前面配置的 url 来访问时，直接来了一个冷冰冰的 <code>404</code>！好吧，莫慌，原来是有延迟，稍等几分钟(我等了半个钟&hellip;)，终于可以正常访问了！</p>

<p>参考：<a href="http://octopress.org/docs/deploying/github/">Deploying to Github Pages</a></p>

<hr />

<h2><strong>更多功能</strong></h2>

<p>在搭建博客的时候，我们可能会对博客做一些配置，例如添加评论、域名解析、分享等。先 mark，以后再慢慢了解吧。</p>

<p>参考：</p>

<blockquote><ul>
<li><a href="http://octopress.org/docs/blogging/code">Sharing Code Snippets</a></li>
<li><a href="http://octopress.org/docs/blogging/plugins">Blogging With Plugins</a></li>
<li><a href="http://octopress.org/docs/theme">Theming &amp; Customization</a></li>
<li><a href="http://octopress.org/docs/updating">Updating Octopress</a></li>
</ul>
</blockquote>

<hr />

<p><strong>承诺</strong></p>

<p>下个死命令：坚持下去，中秋回来以后，每周至少更新 <code>2</code> 篇技术博文！</p>
]]></content>
  </entry>
  
</feed>
